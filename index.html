<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>下落打擊遊戲</title>
  <style>
    body {
      margin: 0;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      justify-content: center;
      color: white;
      font-family: sans-serif;
    }
    canvas {
      background: #111;
      border: 2px solid #444;
    }
    #hud {
      margin-top: 10px;
      text-align: center;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="420" height="600"></canvas>
  <div id="hud">
    <div>分數: <span id="score">0</span></div>
    <div>連擊: <span id="combo">0</span></div>
    <div>判定: <span id="judgement"></span></div>
  </div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const W = canvas.width;
const H = canvas.height;

const laneWidth = W / 4;
const judgeLineY = H - 100;

const keys = ["d","f","j","k"];
const keyDown = new Set();
const keyFlash = { d:0, f:0, j:0, k:0 };

let notes = [];
let score = 0;
let combo = 0;
let judgementText = "";
let judgementTimer = 0;

// 音符生成
function spawnNote() {
  const lane = Math.floor(Math.random() * 4);
  notes.push({ lane, y: -20, hit:false });
}
setInterval(spawnNote, 1000);

// 畫面更新
function render() {
  ctx.clearRect(0,0,W,H);

  // 畫 lane 分隔線
  ctx.strokeStyle = "#333";
  for (let i=1; i<4; i++){
    ctx.beginPath();
    ctx.moveTo(i*laneWidth, 0);
    ctx.lineTo(i*laneWidth, H);
    ctx.stroke();
  }

  // 畫判定圈
  for (let i=0; i<4; i++) {
    const x = i*laneWidth + laneWidth/2;
    ctx.beginPath();
    ctx.arc(x, judgeLineY, 40, 0, Math.PI*2);
    ctx.strokeStyle = keyDown.has(keys[i]) ? "#0f0" : "#555";
    ctx.lineWidth = 3;
    ctx.stroke();

    // 按鍵閃爍效果
    if (keyFlash[keys[i]] > 0) {
      ctx.fillStyle = `rgba(0,255,0,${keyFlash[keys[i]]/10})`;
      ctx.fill();
      keyFlash[keys[i]]--;
    }
  }

  // 畫音符
  ctx.fillStyle = "#0af";
  notes.forEach(n => {
    const x = n.lane * laneWidth + laneWidth/2;
    ctx.beginPath();
    ctx.arc(x, n.y, 25, 0, Math.PI*2);
    ctx.fill();
  });

  // 判定文字
  if (judgementTimer>0) {
    ctx.fillStyle="white";
    ctx.font="24px sans-serif";
    ctx.textAlign="center";
    ctx.fillText(judgementText, W/2, 50);
    judgementTimer--;
  }

  // HUD
  document.getElementById("score").textContent = score;
  document.getElementById("combo").textContent = combo;
}

// 遊戲邏輯
function update() {
  notes.forEach(n => n.y += 5);

  notes = notes.filter(n => {
    if (n.y > H+30) {
      if (!n.hit) { combo=0; judgementText="Miss"; judgementTimer=30; }
      return false;
    }
    return true;
  });
}

// 判定
function judge(k) {
  const lane = keys.indexOf(k);
  if (lane<0) return;

  const target = notes.find(n => n.lane===lane && !n.hit);
  if (target) {
    const diff = Math.abs(target.y - judgeLineY);
    if (diff<40) {
      target.hit=true;
      if (diff<15) { judgementText="Perfect"; score+=100; combo++; }
      else if (diff<30) { judgementText="Great"; score+=70; combo++; }
      else { judgementText="Good"; score+=50; combo++; }
      judgementTimer=30;
    }
  }
  keyFlash[k]=10;
}

// 鍵盤事件
document.addEventListener("keydown", e=>{
  const k = e.key.toLowerCase();
  if (keys.includes(k) && !keyDown.has(k)) {
    keyDown.add(k);
    judge(k);
  }
});
document.addEventListener("keyup", e=>{
  const k = e.key.toLowerCase();
  keyDown.delete(k);
});

// 觸控事件（精準 lane 判定）
canvas.addEventListener("touchstart", e=>{
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  const x = touch.clientX - rect.left;
  const lane = Math.floor(x / (rect.width / 4));
  const k = keys[lane];
  if (k) {
    keyDown.add(k);
    judge(k);
    setTimeout(()=>keyDown.delete(k),100);
  }
});

// 遊戲主循環
function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>














