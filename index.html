<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <!-- è¡Œå‹•è£ç½®ï¼šé—œé–‰ç¸®æ”¾ã€é›™æ“Šæ”¾å¤§ã€pinch -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>DFJK ç¯€å¥éŠæˆ²</title>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
  <style>
    html, body { touch-action: manipulation; }
    body {
      margin: 0; background: #0f1220; color: #fff; font-family: sans-serif;
      text-align: center; transition: background 0.5s ease;
    }
    body.ex-mode { background: linear-gradient(to bottom, #ff3300, #990000, #000000); }

    /* èˆå°å®¹å™¨ï¼ˆæ‰‹æ©Ÿ 1.0ï¼Œæ¡Œæ©Ÿç”¨ --u æ”¾å¤§ï¼‰ */
    #stage {
      position: relative;
      width: 95%;
      max-width: 420px;
      margin: 20px auto;
      --u: 1;
    }

    canvas {
      display: block;
      background: #1f2340;
      border: 2px solid #fff;
      width: 100%;
      height: auto;
      touch-action: manipulation;
    }

    /* DOM hitbar åªæ˜¯å®šä½åƒè€ƒï¼ˆFNF receptor æ”¹ç”± canvas ç•«ï¼‰ */
    .hitbar {
      position: absolute; left: 0; width: 100%;
      display: flex; justify-content: space-between; align-items: center;
      height: calc(90px * var(--u));
      z-index: 2;
      opacity: 0;
      pointer-events: none;
    }
    .hitkey { flex:1; margin:0 5px; height:calc(90px * var(--u)); }

    .hud { font-size: 18px; margin-top: 10px; line-height: 1.6; }
    .songline { font-size: 14px; opacity: .9; }
    button {
      margin:10px; padding:10px 20px; font-size:18px; background:#78d5ff; border:none; border-radius:8px; cursor:pointer;
    }
    #menuScreen, #musicScreen, #endScreen, #optionsScreen, #pauseScreen { padding-top: 120px; }
    .blur { filter: blur(6px); pointer-events: none; user-select: none; }
    #pauseButton { position: absolute; top: 10px; right: 10px; z-index: 3; }

    /* å€’æ•¸æ–‡å­—ï¼šç§»é™¤é–ƒçˆçš„é€æ˜åº¦æ”¹ç‚ºç´”ç¸®æ”¾è„ˆè¡ */
    #countdownText {
      position: absolute; top: 40%; left: 50%; transform: translate(-50%,-50%);
      font-family: 'Fredoka One', sans-serif; font-size: 72px; color: #fff; text-shadow: 2px 2px 8px #000; z-index: 5;
      pointer-events: none;
      opacity: 1;            /* å…¨ç¨‹ç¶­æŒå¯è¦‹ï¼Œä¸ç”¨ 0/1 è·³è®Š */
      will-change: transform;
    }
    @keyframes popScale {
      0%   { transform: translate(-50%,-50%) scale(0.85); }
      50%  { transform: translate(-50%,-50%) scale(1.12); }
      100% { transform: translate(-50%,-50%) scale(1.00); }
    }

    .row { margin: 10px 0; }
    label { margin-right: 6px; }
    select { padding: 6px 10px; border-radius: 6px; border: 1px solid #445; background:#12152a; color:#fff; }

    /* éŸ³æ¨‚é¸å–® */
    #songSelect { width: 90%; max-width: 420px; height: 280px; }
    #musicScreen .hint { opacity: .8; font-size: 14px; margin-top: 6px; }
  </style>
</head>
<body>
  <!-- ä¸»é¸å–® -->
  <div id="menuScreen">
    <h1>ğŸµ DFJK ç¯€å¥éŠæˆ²</h1>
    <div class="row">
      <button onclick="startGame()">é–‹å§‹éŠæˆ²</button>
      <button onclick="showMusic()">éŸ³æ¨‚</button>
      <button onclick="showOptions()">é¸é …</button>
    </div>
    <div class="row">
      å·²é¸æ›²ç›®ï¼š<span id="menuChosenSong">å°šæœªé¸æ“‡</span>
    </div>
  </div>

  <!-- éŸ³æ¨‚é¸å–®ï¼ˆå¿…é¸ï¼‰ -->
  <div id="musicScreen" style="display:none;">
    <h2>ğŸ¼ é¸æ“‡æœ¬å±€æ›²ç›®</h2>
    <div class="row">
      <select id="songSelect" size="12"></select>
      <div class="hint">å¿…é ˆé¸æ“‡æ›²ç›®æ‰å¯é–‹å§‹ã€‚</div>
    </div>
    <div class="row">
      <button onclick="confirmSong()">ç¢ºå®š</button>
      <button onclick="goToMenu()">å›ä¸»é¸å–®</button>
    </div>
    <div class="row">
      å·²é¸ï¼š<span id="chosenSongLabel">å°šæœªé¸æ“‡</span>
    </div>
  </div>

  <!-- é¸é … -->
  <div id="optionsScreen" style="display:none;">
    <h2>âš™ï¸ éŠæˆ²é¸é …</h2>

    <div class="row">
      <label for="difficultySelect">é›£åº¦ï¼š</label>
      <select id="difficultySelect">
        <option value="ex">EXï¼ˆæ¥µé™ï¼‰</option>
        <option value="hell">åœ°ç„</option>
        <option value="hard">å›°é›£</option>
        <option value="normal" selected>æ™®é€š</option>
        <option value="easy">ç°¡å–®</option>
        <option value="beginner">åˆå­¸è€…</option>
      </select>
    </div>

    <div class="row">
      <label for="speedMultiplier">é€Ÿåº¦å€ç‡ï¼š</label>
      <select id="speedMultiplier">
        <option value="1">1.0xï¼ˆæ¨™æº–ï¼‰</option>
        <option value="1.1">1.1x</option>
        <option value="1.2">1.2x</option>
        <option value="1.3">1.3x</option>
        <option value="1.6">1.6x</option>
        <option value="2.0">2.0x</option>
      </select>
    </div>

    <div class="row">
      <label for="noteDirection">éŸ³ç¬¦æ–¹å‘ï¼š</label>
      <select id="noteDirection">
        <option value="down" selected>ä¸‹è½æ‰“æ“Šï¼ˆæ‰“æ“Šç·šåœ¨åº•ï¼‰</option>
        <option value="up">ä¸Šå‡æ‰“æ“Šï¼ˆæ‰“æ“Šç·šåœ¨é ‚ï¼‰</option>
      </select>
    </div>

    <div class="row">
      <label for="judgeMode">åˆ¤å®šæ¨¡å¼ï¼š</label>
      <select id="judgeMode">
        <option value="old" selected>Old Inputï¼ˆå« Ghost æ‡²ç½°ï¼‰</option>
        <option value="new">New Inputï¼ˆç§»é™¤ WRONGï¼‰</option>
      </select>
    </div>

    <div class="row">
      <button onclick="goToMenu()">å›ä¸»é¸å–®</button>
    </div>
  </div>

  <!-- éŠæˆ²ç•«é¢ -->
  <div id="gameScreen" style="display:none; position:relative;">
    <button id="pauseButton" onclick="pauseGame()">â¸ï¸</button>

    <div id="stage">
      <canvas id="gameCanvas" width="420" height="640"></canvas>

      <div class="hitbar">
        <div class="hitkey" id="key-d"></div>
        <div class="hitkey" id="key-f"></div>
        <div class="hitkey" id="key-j"></div>
        <div class="hitkey" id="key-k"></div>
      </div>
    </div>

    <div class="hud">
      åˆ†æ•¸ï¼š<span id="score">0</span>ã€€
      é€£æ“Šï¼š<span id="combo">0</span>ã€€
      åˆ¤å®šï¼š<span id="judgement">-</span>ã€€
      MISSï¼š<span id="missCount">0</span>
      <div class="songline">
        æ›²ç›®ï¼š<span id="songTitle">-</span>ã€€ï½œã€€é›£åº¦ï¼š<span id="diffLabel">-</span>ã€€ï½œã€€æ–¹å‘ï¼š<span id="dirLabel">-</span>ã€€ï½œã€€åˆ¤å®šï¼š<span id="judgeLabel">-</span>
      </div>
    </div>
  </div>

  <!-- æš«åœ -->
  <div id="pauseScreen" style="display:none;">
    <h2>â¸ï¸ éŠæˆ²æš«åœ</h2>
    <button onclick="resumeGame()">â–¶ï¸ ç¹¼çºŒ</button>
    <button onclick="goToMenu()">å›ä¸»é¸å–®</button>
  </div>

  <!-- çµç®— -->
  <div id="endScreen" style="display:none;">
    <h2>ğŸ® éŠæˆ²çµæŸï¼</h2>
    <p>æ›²ç›®ï¼š<span id="finalSong">-</span></p>
    <p>é›£åº¦ï¼š<span id="finalDiff">-</span></p>
    <p>æ–¹å‘ï¼š<span id="finalDir">-</span></p>
    <p>åˆ¤å®šï¼š<span id="finalJudge">-</span></p>
    <p>åˆ†æ•¸ï¼š<span id="finalScore">0</span></p>
    <p>SICKï¼š<span id="statSick">0</span></p>
    <p>GOODï¼š<span id="statGood">0</span></p>
    <p>BADï¼š<span id="statBad">0</span></p>
    <p>SHITï¼š<span id="statShit">0</span></p>
    <p>MISSï¼š<span id="statMiss">0</span></p>
    <button onclick="startGame()">å†ç©ä¸€æ¬¡</button>
    <button onclick="goToMenu()">å›ä¸»é¸å–®</button>
  </div>

  <div id="countdownText" style="display:none;"></div>

  <audio id="hitSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_6e3e3b6f3f.mp3?filename=click-124467.mp3"></audio>
  <audio id="bgm"></audio>

  <script>
    /* ========= åƒæ•¸ ========= */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // å…§éƒ¨éŠæˆ²åº§æ¨™ï¼ˆå›ºå®š 420x640ï¼‰
    const W = canvas.width, H = canvas.height;
    const laneWidth = W / 4;
    const hitbar = document.querySelector('.hitbar');

    // â€”â€” UI ç¸®æ”¾ï¼ˆæ¡Œæ©Ÿæ”¾å¤§ã€æ‰‹æ©Ÿä¸å‹•ï¼‰ â€”â€” //
    const HITKEY_BASE = 90;    // hitbar é«˜åº¦ï¼ˆåŸºæº–ï¼‰
    const NOTE_BASE   = 60;    // ç®­é ­åŸºæº–é‚Š
    let uiScale = 1;

    // ç‹€æ…‹æ©Ÿ
    let phase = 'menu'; // 'menu' | 'countdown' | 'playing' | 'paused'
    let isCountingDown = false;
    let countdownTimers = [];
    let countdownRAF = null;

    function applyDesktopScale() {
      const isCoarse = window.matchMedia('(pointer: coarse)').matches;
      const wide   = window.matchMedia('(min-width: 1024px)').matches;
      const wider  = window.matchMedia('(min-width: 1440px)').matches;
      let u = 1;
      if (!isCoarse && (wide || wider)) u = wider ? 1.8 : 1.5;
      uiScale = u;
      const stage = document.getElementById('stage');
      if (stage) {
        stage.style.setProperty('--u', String(u));
        stage.style.maxWidth = `${Math.round(420 * u)}px`;
      }
      updateHitbarPosition();
    }

    function getCanvasRect(){ return canvas.getBoundingClientRect(); }
    function getScaleY(){ return getCanvasRect().height / H; }
    function getJudgeLineYCss() {
      const rectH = getCanvasRect().height;
      return (currentDirection === 'up') ? (HITKEY_BASE * uiScale / 2) : (rectH - HITKEY_BASE * uiScale / 2);
    }
    function getJudgeLineYInternal() { return getJudgeLineYCss() / getScaleY(); }

    // éŠæˆ²ç‹€æ…‹
    const keys = ['d','f','j','k'];
    const keyToLane = { d:0, f:1, j:2, k:3 };
    const laneDirs = ['left','down','up','right'];

    let score = 0, combo = 0, lastJudgementText = '-';
    let startTime = 0, running = false, paused = false, loopId = null;
    let chart = [], comboFlash = '';
    let elapsedTimeBeforePause = 0;
    let nowT = 0, prevTs = 0;

    const hitSound = document.getElementById('hitSound');
    const bgm = document.getElementById('bgm');

    let baseNoteSpeed = 550;
    let noteSpeed = baseNoteSpeed;

    const FNF_WINDOWS = { sick: 70, good: 118, bad: 123, shit: 138 };
    const FNF_SCORES  = { sick: 350, good: 200, bad: 100, shit: -50, miss: -300, ghost: -150 };
    const MISS_Y_OFFSET = 40;
    const TOUCH_WINDOW_MS = FNF_WINDOWS.shit;
    const LATE_MISS_GRACE_MS = 120;

    // çµ±è¨ˆ
    let missCount = 0;
    let gameOver = false;
    let stats = { sick:0, good:0, bad:0, shit:0, miss:0 };

    // ç•¶å‰è³‡è¨Š
    let currentSongTitle = '-';
    let currentDifficulty = 'normal';
    let currentDirection = 'down';
    let currentJudgeMode = 'old';

    // éŸ³æ¨‚é¸æ“‡ï¼ˆå¿…é¸ï¼‰
    let selectedSongFile = null;

    // æ›²åº«ï¼ˆè«‹ç¢ºä¿ /music æª”åä¸€è‡´ï¼‰
    const SONGS = [
      "Charlie Puth - Light Switch [Official Music Video] - Charlie Puth.mp3",
      "Creepy Nuts - ã‚ªãƒˆãƒã‚±(Otonoke) ã€Official MVã€‘ [Dandandan OP] - Creepy Nuts.mp3",
      "Creepy Nuts â€Mirageâ€ Ã— Anime â€Call of the Nightâ€ Collaboration Music Video Opening Theme Song - Creepy Nuts.mp3",
      "Creepy Nuts â€Nemureâ€ Ã— Anime â€Call of the Nightâ€ Collaboration Music Video Ending Theme Song - Creepy Nuts (1).mp3",
      "Creepy Nutsï½¢Bling-Bang-Bang-Bornï½£ Ã— TV Animeï½¢ãƒãƒƒã‚·ãƒ¥ãƒ«-MASHLE-ï½£ Collaboration Music Video #BBBBãƒ€ãƒ³ã‚¹ - Creepy Nuts.mp3",
      "KANA-BOON - Silhouette - KANABOONVEVO.mp3",
      "Lost Sky - Fearless pt.II (feat. Chris Linton) Trap NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky - Vision pt. II (feat. She Is Jules) Future Trap NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky - Where We Started (feat. Jex) Melodic Dubstep NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky, Sara Skinner - Dreams pt. II (feat. Sara Skinner) [NCS Release].mp3",
      "OneRepublic - Nobody (from Kaiju No. 8) [Official Music Video] - OneRepublicVEVO.mp3",
      "YOASOBIã€ŒWatch me!ã€Official Music Video - Ayase _ YOASOBI.mp3",
      "yung kai - blue (official music video) - yung kai.mp3",
      "ã€AKASAKIã€‘Bunny Girl _ ãƒãƒ‹ãƒ¼ã‚¬ãƒ¼ãƒ«ï¼ˆLyric Videoï¼‰ - AKASAKI (19).mp3",
      "ã€MVã€‘éš™_ã‚†ãƒ¼ã‚Šã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã€‘ - ã‚†ãƒ¼ã‚ŠğŸğŸ¥ã€”24ã€•ãƒ»yuri (1).mp3",
      "ã€imaseã€‘NIGHT DANCERï¼ˆMVï¼‰ - imase.mp3",
      "ã€ã‚ªãƒªã‚¸ãƒŠãƒ«æ¨‚æ›²ã€‘ç²›è–!! ãƒ­ãƒªç¥ãƒ¬ã‚¯ã‚¤ã‚¨ãƒ â˜† _ ã—ãã‚Œã†ã„ï¼ˆ9ã•ã„ï¼‰ã€IOSYSï¼ˆã¾ã‚ã‚“&D.wattï¼‰ã€‘ - ã—ãã‚Œã†ã„.mp3",
      "ãªã¨ã‚Š - Overdose - ãªã¨ã‚Š _ natori.mp3",
      "ãƒ­ã‚¯ãƒ‡ãƒŠã‚·ã€ŒãŸã è²ä¸€ã¤ã€_ Rokudenashi - One Voiceã€Official Music Videoã€‘ - ãƒ­ã‚¯ãƒ‡ãƒŠã‚· _ Rokudenashi.mp3",
      "å¥½ãã ã‹ã‚‰ã€‚_ ã€ãƒ¦ã‚¤ã‚«ã€ã€MVã€‘ - ã€ãƒ¦ã‚¤ã‚«ã€.mp3",
      "å»»å»»å¥‡è­š - Eve MV - Eve.mp3",
      "é’ã®ã™ã¿ã‹ _ ã‚­ã‚¿ãƒ‹ã‚¿ãƒ„ãƒ¤ - Where Our Blue Is _ Tatsuya Kitani - ã‚­ã‚¿ãƒ‹ã‚¿ãƒ„ãƒ¤ _ Tatsuya Kitani.mp3"
    ];

    /* ====== ç•«é¢åˆ‡æ› ====== */
    function showOnly(id) {
      const ids = ['menuScreen','musicScreen','optionsScreen','gameScreen','pauseScreen','endScreen'];
      ids.forEach(x => document.getElementById(x).style.display = (x===id ? 'block' : 'none'));
      if (id !== 'gameScreen') document.getElementById('gameScreen').classList.remove('blur');
    }
    function goToMenu() {
      cancelCountdown();              // <- é˜²æ­¢å€’æ•¸æ®˜ç•™
      stopGameLoop();                 // <- é˜²æ­¢éŠæˆ² RAF æ®˜ç•™
      stopAndResetBgm();              // <- ç«‹åˆ»åœæ­Œ
      showOnly('menuScreen');
      phase = 'menu';
      document.body.classList.remove('ex-mode');
      document.getElementById('menuChosenSong').textContent = selectedSongFile ? selectedSongFile.replace(/\.mp3$/i,'') : 'å°šæœªé¸æ“‡';
    }
    function showOptions() { showOnly('optionsScreen'); }
    function showMusic() {
      const sel = document.getElementById('songSelect');
      if (!sel.dataset.filled) {
        sel.innerHTML = '';
        SONGS.forEach((f) => {
          const opt = document.createElement('option');
          opt.value = f;
          opt.textContent = f.replace(/\.mp3$/i,'');
          sel.appendChild(opt);
        });
        sel.addEventListener('change', () => {
          document.getElementById('chosenSongLabel').textContent = sel.value ? sel.options[sel.selectedIndex].textContent : 'å°šæœªé¸æ“‡';
        });
        sel.dataset.filled = '1';
      }
      showOnly('musicScreen');
    }
    function confirmSong() {
      const sel = document.getElementById('songSelect');
      if (!sel.value) { alert('è«‹å…ˆé¸æ“‡éŸ³æ¨‚'); return; }
      selectedSongFile = sel.value;
      document.getElementById('chosenSongLabel').textContent = sel.options[sel.selectedIndex].textContent;
      document.getElementById('menuChosenSong').textContent = sel.options[sel.selectedIndex].textContent;
      goToMenu();
    }

    /* ====== HUD ====== */
    function updateHUD() {
      document.getElementById('score').textContent = score;
      document.getElementById('combo').textContent = combo;
      document.getElementById('judgement').textContent = lastJudgementText;
      document.getElementById('missCount').textContent = missCount;
      document.getElementById('songTitle').textContent = currentSongTitle;
      document.getElementById('diffLabel').textContent = currentDifficulty.toUpperCase();
      document.getElementById('dirLabel').textContent = (currentDirection === 'up' ? 'ä¸Šå‡' : 'ä¸‹è½');
      document.getElementById('judgeLabel').textContent = (currentJudgeMode === 'old' ? 'Old' : 'New');
    }

    /* ====== è¦–è¦ºï¼ˆFNF ç®­é ­ + ç¾ä»£æ„Ÿï¼‰ ====== */
    const laneColors = ['#b266ff', '#66ccff', '#66ff66', '#ff6666'];
    const receptorPulse = [0,0,0,0];
    const hitFx = [];

    function colorLerp(a, b, t){
      const pa = parseInt(a.slice(1),16), pb = parseInt(b.slice(1),16);
      const ar=(pa>>16)&255, ag=(pa>>8)&255, ab=pa&255;
      const br=(pb>>16)&255, bg=(pb>>8)&255, bb=pb&255;
      const r=Math.round(ar+(br-ar)*t), g=Math.round(ag+(bg-ag)*t), b2=Math.round(ab+(bb-ab)*t);
      return `rgb(${r},${g},${b2})`;
    }
    function dirToAngle(dir){
      switch(dir){ case 'up': return 0; case 'down': return Math.PI; case 'left': return -Math.PI/2; case 'right': return Math.PI/2; }
      return 0;
    }
    function drawArrow(x, y, size, dir, baseColor, glow = 1, innerScale = 0.7){
      const angle = dirToAngle(dir);
      const Hh = size * 1.15, Wd = size, headH = Hh * 0.55;

      const drawShape = (scale=1, fillStyle=baseColor, strokeStyle='#000', shadow=0)=>{
        ctx.save(); ctx.translate(x, y); ctx.rotate(angle); ctx.scale(scale, scale);
        if (shadow>0){ ctx.shadowColor = baseColor; ctx.shadowBlur = shadow; }
        ctx.beginPath();
        ctx.moveTo(0, -Hh/2);
        ctx.lineTo(Wd/2, -Hh/2 + headH);
        ctx.lineTo(Wd*0.22, -Hh/2 + headH);
        ctx.lineTo(Wd*0.22,  Hh/2);
        ctx.lineTo(-Wd*0.22, Hh/2);
        ctx.lineTo(-Wd*0.22, -Hh/2 + headH);
        ctx.lineTo(-Wd/2, -Hh/2 + headH);
        ctx.closePath();
        const grad = ctx.createLinearGradient(0, -Hh/2, 0, Hh/2);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.25, colorLerp('#ffffff', baseColor, .2));
        grad.addColorStop(1, baseColor);
        ctx.fillStyle = (fillStyle === 'gradient') ? grad : fillStyle;
        ctx.fill();
        ctx.lineWidth = 6; ctx.strokeStyle = strokeStyle; ctx.stroke();
        ctx.restore();
      };
      drawShape(1.0, 'gradient', '#000000', 16*glow);
      drawShape(innerScale, 'gradient', colorLerp(baseColor,'#ffffff',0.25), 6*glow);
    }
    function drawRing(x,y,r,alpha){
      ctx.save(); ctx.globalAlpha = alpha;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
      ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 3; ctx.stroke();
      ctx.restore();
    }
    function flashKeyByLane(laneIdx) { receptorPulse[laneIdx] = 1; }

    /* ====== åˆ¤å®š ====== */
    function judge(dtMs, lane) {
      const adt = Math.abs(dtMs);
      let rating = '', scoreDelta = 0;
      if (adt <= FNF_WINDOWS.sick)      { rating = 'SICK!'; scoreDelta = FNF_SCORES.sick; stats.sick++; combo++; }
      else if (adt <= FNF_WINDOWS.good) { rating = 'GOOD';  scoreDelta = FNF_SCORES.good; stats.good++; combo++; }
      else if (adt <= FNF_WINDOWS.bad)  { rating = 'BAD';   scoreDelta = FNF_SCORES.bad;  stats.bad++;  combo++; }
      else if (adt <= FNF_WINDOWS.shit) { rating = 'SHIT';  scoreDelta = FNF_SCORES.shit; stats.shit++; combo = Math.max(0, combo-1); }
      else { miss(); return; }
      score = Math.max(0, score + scoreDelta);
      lastJudgementText = rating;
      receptorPulse[lane] = 1;
      hitFx.push({lane, t0: nowT, life: 0.25});
      updateHUD();
      try{ hitSound.currentTime = 0; hitSound.play(); }catch{}
      if (combo > 0 && combo % 10 === 0) { comboFlash = `COMBO x${combo}!!`; setTimeout(() => comboFlash = '', 800); }
    }
    function miss() {
      lastJudgementText = 'MISS';
      combo = 0; missCount++; stats.miss++;
      score = Math.max(0, score + FNF_SCORES.miss);
      updateHUD();
      if (currentDifficulty === 'ex' && missCount > 15) triggerFailOnce('ä½ è¼¸äº†ï¼EX æ¨¡å¼ MISS è¶…é 15 æ¬¡');
    }
    function ghostTap(lane) { lastJudgementText='MISS'; combo=0; score=Math.max(0, score+FNF_SCORES.ghost); receptorPulse[lane]=0.5; updateHUD(); }
    function triggerFailOnce(msg) {
      if (gameOver) return; gameOver = true; running = false;
      stopGameLoop(); stopAndResetBgm();
      setTimeout(() => { alert(msg); goToMenu(); }, 0);
    }

    /* ====== è‡ªå‹•ç”Ÿè­œï¼ˆåŸç‰ˆé›£åº¦ï¼‰ ====== */
    function generateChart(durationSec) {
      chart = [];
      const difficulty = currentDifficulty;
      let doubleNoteChance = 0.35;
      let timeGapMin = 0.20;
      let timeGapMax = 0.45;
      if (difficulty === 'beginner')      { doubleNoteChance = 0.15; timeGapMin = 0.30; timeGapMax = 0.60; }
      else if (difficulty === 'easy')     { doubleNoteChance = 0.20; timeGapMin = 0.25; timeGapMax = 0.50; }
      else if (difficulty === 'normal')   { doubleNoteChance = 0.35; timeGapMin = 0.20; timeGapMax = 0.45; }
      else if (difficulty === 'hard')     { doubleNoteChance = 0.55; timeGapMin = 0.15; timeGapMax = 0.35; }

      if (!(difficulty === 'ex' || difficulty === 'hell')) {
        let time = 1;
        while (time < durationSec) {
          const lanesUsed = new Set();
          const notesThisFrame = [];
          const count = Math.random() < doubleNoteChance ? 2 : 1;
          while (notesThisFrame.length < count) {
            const lane = Math.floor(Math.random() * 4);
            if (!lanesUsed.has(lane)) {
              lanesUsed.add(lane);
              notesThisFrame.push({ t: time, lane, type: 'tap', hit: false, y: -50 });
            }
          }
          chart.push(...notesThisFrame);
          time += Math.random() * (timeGapMax - timeGapMin) + timeGapMin;
        }
        return;
      }

      // EX / HELLï¼ˆåŸæœ¬çš„è¼ƒå¯†é›†é‚è¼¯ï¼‰
      const beat = 0.5;
      let t = 1;
      let laneCursor = 0;
      const nextLane = () => { laneCursor = (laneCursor + 1) % 4; return laneCursor; };
      const pushNote = (tt, lane) => chart.push({ t: tt, lane, type: 'tap', hit: false, y: -50 });
      const randLane = () => Math.floor(Math.random() * 4);

      while (t < durationSec) {
        if (difficulty === 'ex') {
          pushNote(t, nextLane());
          if (Math.random() < 0.60) pushNote(t, (laneCursor + 2) % 4);
          if (Math.random() < 0.35) pushNote(t + beat / 2, (laneCursor + 1) % 4);
          if (Math.random() < 0.18) {
            pushNote(t + beat / 3, randLane());
            pushNote(t + 2 * beat / 3, randLane());
          }
          t += Math.random() < 0.5 ? beat / 2 : beat;
        } else {
          pushNote(t, nextLane());
          if (Math.random() < 0.85) pushNote(t, (laneCursor + 2) % 4);
          pushNote(t + beat / 2, (laneCursor + 1) % 4);
          if (Math.random() < 0.4) {
            pushNote(t + beat / 4, randLane());
            pushNote(t + 3 * beat / 4, randLane());
          }
          t += beat / 2;
        }
      }
    }

    /* ====== å¹¾ä½• & å‘½ä¸­åˆ¤å®š ====== */
    function noteYAtTimeFor(tHit, tNow) {
      const judge = getJudgeLineYInternal();
      if (currentDirection === 'down') return judge - (tHit - tNow) * noteSpeed;
      return judge + (tHit - tNow) * noteSpeed;
    }
    function isTapMiss(n, currentTimeSec) {
      const judge = getJudgeLineYInternal();
      const dtMs = (currentTimeSec - n.t) * 1000;
      const beyondDown = n.y > judge + MISS_Y_OFFSET;
      const beyondUp = n.y < judge - MISS_Y_OFFSET;
      const graceOver = dtMs > LATE_MISS_GRACE_MS;
      return (currentDirection === 'down') ? (beyondDown && graceOver) : (beyondUp && graceOver);
    }

    /* ====== æ›´æ–° & ç¹ªåœ– ====== */
    function updateHitbarPosition() {
      if (!hitbar || document.getElementById('gameScreen').style.display === 'none') return;
      const topPx = getJudgeLineYCss() - (HITKEY_BASE * uiScale / 2);
      hitbar.style.top = `${topPx}px`;
    }

    function update(t, dt) {
      chart.forEach(n => { n.y = noteYAtTimeFor(n.t, t); });
      chart.forEach(n => { if (!n.hit && isTapMiss(n, t)) { n.hit = true; miss(); } });
      for (let i=0;i<4;i++) receptorPulse[i] = Math.max(0, receptorPulse[i] - dt*3.2);
      for (let i = hitFx.length-1; i>=0; i--) if (t - hitFx[i].t0 > hitFx[i].life) hitFx.splice(i,1);
    }

    function render({skipNotes=false} = {}) {
      const judge = getJudgeLineYInternal();
      ctx.clearRect(0, 0, W, H);

      // receptorï¼ˆå€’æ•¸ä¹Ÿç•«ï¼‰
      for (let lane=0; lane<4; lane++){
        const x = lane * laneWidth + laneWidth / 2;
        const pulse = receptorPulse[lane];
        const glowScale = 1 + 0.18 * pulse;
        drawArrow(x, judge, NOTE_BASE * glowScale, laneDirs[lane], laneColors[lane], 0.8 + pulse);
      }

      // éŸ³ç¬¦ï¼ˆå€’æ•¸æ™‚ä¸ç•«ï¼Œé¿å…èª¤è§£æ­£åœ¨é–‹å§‹ï¼‰
      if (!skipNotes) {
        chart.forEach(n => {
          if (n.hit) return;
          const x = n.lane * laneWidth + laneWidth / 2;
          drawArrow(x, n.y, NOTE_BASE, laneDirs[n.lane], laneColors[n.lane], 0.6);
        });
      }

      hitFx.forEach(fx=>{
        const x = fx.lane * laneWidth + laneWidth / 2;
        const p = Math.min(1, (nowT - fx.t0) / fx.life);
        drawRing(x, judge, 18 + 80*p, 1 - p);
      });

      if (lastJudgementText !== '-') {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        const offset = (currentDirection === 'up') ? 120 : -40;
        ctx.fillText(lastJudgementText, W / 2, judge + offset);
      }

      if (comboFlash) {
        ctx.fillStyle = '#ff78b5';
        ctx.font = 'bold 36px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(comboFlash, W / 2, H / 2 - 100);
      }
    }

    function loop(ts) {
      if (paused) return;
      if (!prevTs) prevTs = ts;
      nowT = (ts - startTime) / 1000;
      const dt = Math.max(0, (ts - prevTs) / 1000);
      prevTs = ts;

      update(nowT, dt);
      render();

      if (chart.every(n => n.hit)) {
        running = false;
        lastJudgementText = 'END';
        updateHUD();
        document.getElementById('finalSong').textContent = currentSongTitle;
        document.getElementById('finalDiff').textContent = currentDifficulty.toUpperCase();
        document.getElementById('finalDir').textContent  = (currentDirection === 'up' ? 'ä¸Šå‡' : 'ä¸‹è½');
        document.getElementById('finalJudge').textContent= (currentJudgeMode === 'old' ? 'Old' : 'New');
        document.getElementById('finalScore').textContent = score;
        document.getElementById('statSick').textContent = stats.sick;
        document.getElementById('statGood').textContent = stats.good;
        document.getElementById('statBad').textContent = stats.bad;
        document.getElementById('statShit').textContent = stats.shit;
        document.getElementById('statMiss').textContent = stats.miss;

        showOnly('endScreen');
        phase = 'menu';
        return;
      }

      loopId = requestAnimationFrame(loop);
    }
    function stopGameLoop(){ try{ cancelAnimationFrame(loopId); }catch{} loopId=null; prevTs=0; }

    /* ====== å€’æ•¸è™•ç†ï¼ˆå¯ä¸­æ­¢ï¼‰ ====== */
    function showCountdown(startCallback) {
      cancelCountdown();                 // ç¢ºä¿ä¹¾æ·¨
      isCountingDown = true;
      phase = 'countdown';

      // å€’æ•¸æ™‚å…ˆé¡¯ç¤º receptorï¼ˆä¸ç•«éŸ³ç¬¦ï¼‰
      const countdownLoop = () => {
        if (!isCountingDown) return;
        render({skipNotes:true});
        countdownRAF = requestAnimationFrame(countdownLoop);
      };
      countdownLoop();

      const el = document.getElementById('countdownText');
      el.style.display = 'block';
      const steps = ['Ready', '3', '2', '1', 'Go!'];
      const stepDur = 700;

      const playStep = (i) => {
        if (!isCountingDown) return;
        el.textContent = steps[i];
        // ç„¡é–ƒçˆï¼šåªåšç¸®æ”¾å‹•ç•«
        el.style.animation = 'none';
        // è§¸ç™¼ä¸€æ¬¡é‡æ’ä»¥é‡å•Ÿå‹•ç•«
        void el.offsetWidth;
        el.style.animation = 'popScale .55s ease-out';
      };

      // é€æ­¥æ’ç¨‹
      for (let i=0;i<steps.length;i++){
        countdownTimers.push(setTimeout(()=>playStep(i), i*stepDur));
      }
      // çµæŸå¾Œå•Ÿå‹•éŠæˆ²
      countdownTimers.push(setTimeout(()=>{
        if (!isCountingDown) return;
        el.style.display = 'none';
        isCountingDown = false;
        cancelAnimationFrame(countdownRAF);
        startCallback();                 // çœŸæ­£é–‹å§‹
      }, steps.length*stepDur));
    }

    function cancelCountdown() {
      if (!isCountingDown && countdownTimers.length===0 && !countdownRAF) return;
      isCountingDown = false;
      countdownTimers.forEach(id=>clearTimeout(id));
      countdownTimers = [];
      try{ cancelAnimationFrame(countdownRAF); }catch{}
      countdownRAF = null;
      const el = document.getElementById('countdownText');
      el.style.animation = 'none';
      el.style.display = 'none';
    }

    function stopAndResetBgm(){
      try { bgm.pause(); } catch {}
      try { bgm.currentTime = 0; } catch {}
    }

    /* ====== è¼¸å…¥ï¼ˆéµç›¤ï¼‹è§¸æ§ï¼‰ ====== */
    window.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();

      if (k in keyToLane) {
        // å€’æ•¸æ™‚ç¦æ­¢æ‰“éµï¼ˆåƒ…å±•ç¤º receptorï¼‰
        if (phase === 'playing') onLanePress(keyToLane[k]);
        e.preventDefault();
        return;
      }

      if (e.key === 'Escape') {
        if (phase === 'countdown') {        // << ä¿®å¾©ï¼šå€’æ•¸ä¸­ ESC ç›´æ¥å›ä¸»é¸å–®ä¸”åœæ­Œ
          cancelCountdown();
          goToMenu();
          return;
        }
        if (phase === 'playing') { paused ? resumeGame() : pauseGame(); return; }
        if (phase === 'paused')  { resumeGame(); return; }
      }
    });

    canvas.addEventListener('pointerdown', (e) => {
      if (phase !== 'playing') return;      // å€’æ•¸æ™‚ä¸è™•ç†é»æ“Š
      e.preventDefault();
      const rect = getCanvasRect();
      const x = e.clientX - rect.left;
      const cssLaneWidth = rect.width / 4;
      const lane = Math.min(3, Math.max(0, Math.floor(x / cssLaneWidth)));
      onLanePress(lane);
    }, { passive:false });

    function onLanePress(lane) {
      if (!running) return;
      const tNow = (performance.now() - startTime) / 1000;

      let bestIdx = -1, bestAbs = Infinity;
      for (let i = 0; i < chart.length; i++) {
        const n = chart[i];
        if (n.hit || n.lane !== lane) continue;
        const dtMs = (tNow - n.t) * 1000;
        const adt = Math.abs(dtMs);
        if (adt <= TOUCH_WINDOW_MS && adt < bestAbs) { bestAbs = adt; bestIdx = i; }
      }

      if (bestIdx >= 0) {
        const n = chart[bestIdx];
        judge((tNow - n.t) * 1000, lane);
        n.hit = true;
        flashKeyByLane(lane);
      } else {
        if (currentJudgeMode === 'old') ghostTap(lane);
        flashKeyByLane(lane);
      }
    }

    /* ====== æµç¨‹ ====== */
    function startGame() {
      if (!selectedSongFile) { alert('è«‹å…ˆé¸æ“‡éŸ³æ¨‚'); showMusic(); return; }

      const difficulty = document.getElementById('difficultySelect').value;
      const speedMultiplierSelect = document.getElementById('speedMultiplier');
      const dir = document.getElementById('noteDirection').value;
      const jmode = document.getElementById('judgeMode').value;
      currentDifficulty = difficulty;
      currentDirection  = dir;
      currentJudgeMode  = jmode;

      let multiplier = parseFloat(speedMultiplierSelect.value);
      if      (difficulty === 'beginner') multiplier = 0.8;
      else if (difficulty === 'easy')     multiplier = 0.9;
      else if (difficulty === 'ex')       multiplier = 1.8;
      noteSpeed = baseNoteSpeed * multiplier;

      document.body.classList.toggle('ex-mode', difficulty === 'ex');

      // é‡ç½®ç‹€æ…‹
      stopGameLoop();
      score = 0; combo = 0; lastJudgementText = '-'; comboFlash = '';
      chart = []; paused = false; running = true; missCount = 0; gameOver = false;
      stats = { sick:0, good:0, bad:0, shit:0, miss:0 };
      elapsedTimeBeforePause = 0; nowT = 0; prevTs = 0;
      for (let i=0;i<4;i++) receptorPulse[i]=0;
      hitFx.length = 0;
      updateHUD();

      currentSongTitle = selectedSongFile.replace(/\.mp3$/i, '');
      const url = 'music/' + encodeURIComponent(selectedSongFile);
      bgm.src = url; bgm.load();

      showOnly('gameScreen');
      phase = 'countdown';

      applyDesktopScale();
      requestAnimationFrame(updateHitbarPosition);
      setTimeout(updateHitbarPosition, 0);
      setTimeout(updateHitbarPosition, 50);

      updateHUD();

      let chartFinalized = false;
      generateChart(120);
      bgm.onloadedmetadata = () => {
        if (chartFinalized) return;
        const durationSec = (!isNaN(bgm.duration) && bgm.duration > 0) ? bgm.duration : 120;
        generateChart(durationSec);
        chartFinalized = true;
      };

      // å€’æ•¸ï¼ˆé¡¯ç¤º receptorã€ä¸é¡¯ç¤ºéŸ³ç¬¦ï¼›å¯ä¸­æ­¢ï¼‰
      showCountdown(() => {
        if (phase !== 'countdown') return;  // è‹¥è¢«ä¸­æ­¢å°±ä¸å•Ÿå‹•
        phase = 'playing';
        startTime = performance.now();
        try { bgm.currentTime = 0; bgm.play().catch(()=>{}); } catch {}
        loopId = requestAnimationFrame(loop);
      });
    }

    function pauseGame() {
      if (phase === 'countdown') {
        // å€’æ•¸æ™‚æŒ‰æš«åœéµï¼šç›´æ¥è¦–ç‚ºå–æ¶ˆå›ä¸»é¸å–®
        cancelCountdown();
        goToMenu();
        return;
      }
      if (!running || paused) return;
      paused = true;
      phase = 'paused';
      try { bgm.pause(); } catch {}
      stopGameLoop();
      elapsedTimeBeforePause = (performance.now() - startTime) / 1000;
      document.getElementById('gameScreen').classList.add('blur');
      showOnly('pauseScreen');
    }

    function resumeGame() {
      if (!paused) return;
      paused = false;
      phase = 'playing';
      showOnly('gameScreen');
      document.getElementById('gameScreen').classList.remove('blur');

      applyDesktopScale();
      requestAnimationFrame(updateHitbarPosition);

      startTime = performance.now() - (elapsedTimeBeforePause * 1000);
      try { bgm.play().catch(()=>{}); } catch {}
      loopId = requestAnimationFrame(loop);
    }

    /* ====== åˆå§‹åŒ– ====== */
    function renderIdle() {
      // åœ¨ä¸»é¸å–®/é¸é …/éŸ³æ¨‚é ä¹Ÿèƒ½ç¶­æŒèˆå°æ¯”ä¾‹é‹ç®—
      if (document.getElementById('gameScreen').style.display === 'block') return;
      updateHitbarPosition();
    }

    applyDesktopScale();
    window.addEventListener('resize', () => { applyDesktopScale(); renderIdle(); }, { passive: true });
    window.addEventListener('scroll', updateHitbarPosition, { passive: true });
    if (window.visualViewport) {
      ['resize','scroll'].forEach(ev => {
        window.visualViewport.addEventListener(ev, () => { applyDesktopScale(); }, { passive: true });
      });
    }

    // ç¦å³éµ / ç¦ç¸®æ”¾
    document.addEventListener("contextmenu", e => e.preventDefault());
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('dblclick', e => e.preventDefault());

    goToMenu();
  </script>
</body>
</html>











