<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <!-- è¡Œå‹•è£ç½®ï¼šé—œé–‰ç¸®æ”¾ã€é›™æ“Šæ”¾å¤§ã€pinch -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>DFJK ç¯€å¥éŠæˆ²</title>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
  <style>
    html, body { touch-action: manipulation; }
    body {
      margin: 0; background: #0f1220; color: #fff; font-family: sans-serif;
      text-align: center; transition: background 0.5s ease;
    }
    body.ex-mode { background: linear-gradient(to bottom, #ff3300, #990000, #000000); }

    /* èˆå°å®¹å™¨ï¼ˆæ‰‹æ©Ÿ 1.0ï¼Œæ¡Œæ©Ÿç”¨ --u æ”¾å¤§ï¼‰ */
    #stage {
      position: relative;
      width: 95%;
      max-width: 420px;
      margin: 20px auto;
      --u: 1;
    }

    canvas {
      display: block;
      background: #1f2340;
      border: 2px solid #fff;
      width: 100%;
      height: auto;
      touch-action: manipulation;
    }

    /* DOM hitbar åªæ˜¯å®šä½åƒè€ƒï¼ˆFNF receptor æ”¹ç”± canvas ç•«ï¼‰ */
    .hitbar {
      position: absolute; left: 0; width: 100%;
      display: flex; justify-content: space-between; align-items: center;
      height: calc(90px * var(--u));
      z-index: 2;
      opacity: 0;
      pointer-events: none;
    }
    .hitkey { flex:1; margin:0 5px; height:calc(90px * var(--u)); }

    .hud { font-size: 18px; margin-top: 10px; line-height: 1.6; }
    .songline { font-size: 14px; opacity: .9; }
    button {
      margin:10px; padding:10px 20px; font-size:18px; background:#78d5ff; border:none; border-radius:8px; cursor:pointer;
    }
    #menuScreen, #musicScreen, #endScreen, #optionsScreen, #pauseScreen { padding-top: 120px; }
    .blur { filter: blur(6px); pointer-events: none; user-select: none; }
    #pauseButton { position: absolute; top: 10px; right: 10px; z-index: 3; }
    /* æ‰‹æ©Ÿ + ä¸Šå‡æ‰“æ“Šæ™‚æŠŠæš«åœéµç§»åˆ°åº•éƒ¨é¿å…è“‹åˆ°å³å´ lane */
    .pause-bottom { top: auto !important; bottom: 10px !important; }

    /* å€’æ•¸æ–‡å­—ï¼šç´”ç¸®æ”¾è„ˆè¡ */
    #countdownText {
      position: absolute; top: 40%; left: 50%; transform: translate(-50%,-50%);
      font-family: 'Fredoka One', sans-serif; font-size: 72px; color: #fff; text-shadow: 2px 2px 8px #000; z-index: 5;
      pointer-events: none; opacity: 1; will-change: transform;
    }
    @keyframes popScale {
      0% { transform: translate(-50%,-50%) scale(0.85); }
      50% { transform: translate(-50%,-50%) scale(1.12); }
      100% { transform: translate(-50%,-50%) scale(1.00); }
    }

    .row { margin: 10px 0; }
    label { margin-right: 6px; }
    select { padding: 6px 10px; border-radius: 6px; border: 1px solid #445; background:#12152a; color:#fff; }

    /* éŸ³æ¨‚é¸å–® */
    #songSelect { width: 90%; max-width: 420px; height: 280px; }
    #musicScreen .hint { opacity: .8; font-size: 14px; margin-top: 6px; }

    /* å°å‹æç¤ºæ©«å¹… */
    #warnBanner {
      position: fixed; left: 50%; bottom: 20px; transform: translateX(-50%);
      background: rgba(255,80,80,.95); padding: 10px 14px; border-radius: 8px; font-size: 14px;
      display: none; z-index: 20;
    }
  </style>
</head>
<body>
  <!-- ä¸»é¸å–® -->
  <div id="menuScreen">
    <h1>ğŸµ DFJK ç¯€å¥éŠæˆ²</h1>
    <div class="row">
      <button onclick="startGame()">é–‹å§‹éŠæˆ²</button>
      <button onclick="showMusic()">éŸ³æ¨‚</button>
      <button onclick="showOptions()">é¸é …</button>
    </div>
    <div class="row">
      å·²é¸æ›²ç›®ï¼š<span id="menuChosenSong">å°šæœªé¸æ“‡</span>
    </div>
  </div>

  <!-- éŸ³æ¨‚é¸å–®ï¼ˆå¿…é¸ï¼‰ -->
  <div id="musicScreen" style="display:none;">
    <h2>ğŸ¼ é¸æ“‡æœ¬å±€æ›²ç›®</h2>
    <div class="row">
      <select id="songSelect" size="12"></select>
      <div class="hint">å¿…é ˆé¸æ“‡æ›²ç›®æ‰å¯é–‹å§‹ã€‚</div>
    </div>
    <div class="row">
      <button onclick="confirmSong()">ç¢ºå®š</button>
      <button onclick="goToMenu()">å›ä¸»é¸å–®</button>
    </div>
    <div class="row">
      å·²é¸ï¼š<span id="chosenSongLabel">å°šæœªé¸æ“‡</span>
    </div>
  </div>

  <!-- é¸é … -->
  <div id="optionsScreen" style="display:none;">
    <h2>âš™ï¸ éŠæˆ²é¸é …</h2>

    <div class="row">
      <label for="difficultySelect">é›£åº¦ï¼š</label>
      <select id="difficultySelect">
        <option value="ex">EXï¼ˆæ¥µé™ï¼‰</option>
        <option value="hell">åœ°ç„</option>
        <option value="hard">å›°é›£</option>
        <option value="normal" selected>æ™®é€š</option>
        <option value="easy">ç°¡å–®</option>
        <option value="beginner">åˆå­¸è€…</option>
      </select>
    </div>

    <div class="row">
      <label for="speedMultiplier">é€Ÿåº¦å€ç‡ï¼š</label>
      <select id="speedMultiplier">
        <option value="1">1.0xï¼ˆæ¨™æº–ï¼‰</option>
        <option value="1.1">1.1x</option>
        <option value="1.2">1.2x</option>
        <option value="1.3">1.3x</option>
        <option value="1.6">1.6x</option>
        <option value="2.0">2.0x</option>
      </select>
    </div>

    <div class="row">
      <label for="noteDirection">éŸ³ç¬¦æ–¹å‘ï¼š</label>
      <select id="noteDirection">
        <option value="down" selected>ä¸‹è½æ‰“æ“Šï¼ˆæ‰“æ“Šç·šåœ¨åº•ï¼‰</option>
        <option value="up">ä¸Šå‡æ‰“æ“Šï¼ˆæ‰“æ“Šç·šåœ¨é ‚ï¼‰</option>
      </select>
    </div>

    <div class="row">
      <label for="judgeMode">åˆ¤å®šæ¨¡å¼ï¼š</label>
      <select id="judgeMode">
        <option value="old" selected>Old Inputï¼ˆå« Ghost æ‡²ç½°ï¼‰</option>
        <option value="new">New Inputï¼ˆç§»é™¤ WRONGï¼‰</option>
      </select>
    </div>

    <!-- éŸ³é‡ -->
    <div class="row">
      <label for="volumeSlider">éŸ³é‡ï¼š</label>
      <input id="volumeSlider" type="range" min="0" max="100" value="80" />
      <span id="volumeLabel">80%</span>
    </div>

    <div class="row">
      <button onclick="goToMenu()">å›ä¸»é¸å–®</button>
    </div>
  </div>

  <!-- éŠæˆ²ç•«é¢ -->
  <div id="gameScreen" style="display:none; position:relative;">
    <button id="pauseButton" onclick="pauseGame()">â¸ï¸</button>

    <div id="stage">
      <canvas id="gameCanvas" width="420" height="640"></canvas>

      <div class="hitbar">
        <div class="hitkey" id="key-d"></div>
        <div class="hitkey" id="key-f"></div>
        <div class="hitkey" id="key-j"></div>
        <div class="hitkey" id="key-k"></div>
      </div>
    </div>

    <div class="hud">
      åˆ†æ•¸ï¼š<span id="score">0</span>ã€€
      é€£æ“Šï¼š<span id="combo">0</span>ã€€
      åˆ¤å®šï¼š<span id="judgement">-</span>ã€€
      MISSï¼š<span id="missCount">0</span>
      <div class="songline">
        æ›²ç›®ï¼š<span id="songTitle">-</span>ã€€ï½œã€€é›£åº¦ï¼š<span id="diffLabel">-</span>ã€€ï½œã€€æ–¹å‘ï¼š<span id="dirLabel">-</span>ã€€ï½œã€€åˆ¤å®šï¼š<span id="judgeLabel">-</span>
      </div>
    </div>
  </div>

  <!-- æš«åœ -->
  <div id="pauseScreen" style="display:none;">
    <h2>â¸ï¸ éŠæˆ²æš«åœ</h2>
    <button onclick="resumeGame()">â–¶ï¸ ç¹¼çºŒ</button>
    <button onclick="goToMenu()">å›ä¸»é¸å–®</button>
  </div>

  <!-- çµç®— -->
  <div id="endScreen" style="display:none;">
    <h2>ğŸ® éŠæˆ²çµæŸï¼</h2>
    <p>æ›²ç›®ï¼š<span id="finalSong">-</span></p>
    <p>é›£åº¦ï¼š<span id="finalDiff">-</span></p>
    <p>æ–¹å‘ï¼š<span id="finalDir">-</span></p>
    <p>åˆ¤å®šï¼š<span id="finalJudge">-</span></p>
    <p>åˆ†æ•¸ï¼š<span id="finalScore">0</span></p>
    <p>SICKï¼š<span id="statSick">0</span></p>
    <p>GOODï¼š<span id="statGood">0</span></p>
    <p>BADï¼š<span id="statBad">0</span></p>
    <p>SHITï¼š<span id="statShit">0</span></p>
    <p>MISSï¼š<span id="statMiss">0</span></p>
    <button onclick="startGame()">å†ç©ä¸€æ¬¡</button>
    <button onclick="goToMenu()">å›ä¸»é¸å–®</button>
  </div>

  <div id="countdownText" style="display:none;"></div>

  <div id="warnBanner">âš ï¸ éŸ³æ¨‚ç„¡æ³•æ’­æ”¾ï¼šè«‹ç¢ºèªæª”å/è·¯å¾‘ï¼Œæˆ–é»ä¸€ä¸‹ç•«é¢å†æŒ‰é–‹å§‹ã€‚</div>

  <!-- éŸ³æ•ˆï¼šé˜è²ï¼ˆå‘½ä¸­èˆ‡ç©ºæ‰“éƒ½æœƒæ’­æ”¾ï¼‰ -->
  <audio id="hitSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_6e3e3b6f3f.mp3?filename=click-124467.mp3" preload="auto"></audio>
  <audio id="bgm" preload="auto"></audio>

  <script>
    /* ========= åƒæ•¸ ========= */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

    // å…§éƒ¨éŠæˆ²åº§æ¨™ï¼ˆå›ºå®š 420x640ï¼‰
    const W = canvas.width, H = canvas.height;
    const laneWidth = W / 4;
    const hitbar = document.querySelector('.hitbar');

    // â€”â€” UI ç¸®æ”¾ï¼ˆæ¡Œæ©Ÿæ”¾å¤§ã€æ‰‹æ©Ÿä¸å‹•ï¼‰ â€”â€” //
    const HITKEY_BASE = 90;    // hitbar é«˜åº¦ï¼ˆåŸºæº–ï¼‰
    const NOTE_BASE   = 60;    // ç®­é ­åŸºæº–é‚Š
    let uiScale = 1;

    // ç‹€æ…‹æ©Ÿ
    let phase = 'menu'; // 'menu' | 'countdown' | 'playing' | 'paused'
    let isCountingDown = false;
    let countdownTimers = [];
    let countdownRAF = null;

    // ====== æ‰‹æ©Ÿç©©å®š 60fpsï¼ˆåªç¯€æµã€Œæ¸²æŸ“ã€ï¼Œåˆ¤å®šä»ç”¨çœŸå¯¦æ™‚é–“ï¼‰ ======
    const IS_MOBILE = window.matchMedia('(pointer: coarse)').matches;
    let __fpsMode = IS_MOBILE ? 'stable60' : 'unlocked';
    let __lastRenderTs = 0;
    const __TARGET_INTERVAL = 1000 / 60;

    function applyDesktopScale() {
      const isCoarse = window.matchMedia('(pointer: coarse)').matches;
      const wide   = window.matchMedia('(min-width: 1024px)').matches;
      const wider  = window.matchMedia('(min-width: 1440px)').matches;
      let u = 1;
      if (!isCoarse && (wide || wider)) u = wider ? 1.8 : 1.5;
      uiScale = u;
      const stage = document.getElementById('stage');
      if (stage) {
        stage.style.setProperty('--u', String(u));
        stage.style.maxWidth = `${Math.round(420 * u)}px`;
      }
      recomputeLayout();
    }

    // ====== ç‰ˆé¢å¿«å–ï¼ˆé¿å…æ¯å¹€ reflowï¼‰ ======
    let cachedRectHeight = canvas.getBoundingClientRect().height;
    let cachedScaleY = cachedRectHeight / H;
    let cachedJudgeLineCss = (HITKEY_BASE * uiScale / 2);
    let cachedJudgeLineInternal = cachedJudgeLineCss / cachedScaleY;

    // === éŠæˆ²ä¸­å‡çµç‰ˆé¢ï¼ˆé¿å…ä½ç§»ï¼‰ ===
    let __layoutFrozen = false;
    let __frozenRectHeight = null, __frozenScaleY = null, __frozenJudgeCss = null;

    function freezeLayout() {
      const rect = canvas.getBoundingClientRect();
      __frozenRectHeight = rect.height;
      __frozenScaleY = __frozenRectHeight / H;
      __frozenJudgeCss = (currentDirection === 'up')
        ? (HITKEY_BASE * uiScale / 2)
        : (__frozenRectHeight - HITKEY_BASE * uiScale / 2);
      __layoutFrozen = true;
      updateHitbarPosition();
    }

    function unfreezeLayout() {
      __layoutFrozen = false;
      recomputeLayout();
    }

    function recomputeLayout() {
      if (__layoutFrozen) return;
      const rect = canvas.getBoundingClientRect();
      cachedRectHeight = rect.height;
      cachedScaleY = cachedRectHeight / H;
      cachedJudgeLineCss = (currentDirection === 'up') ? (HITKEY_BASE * uiScale / 2) : (cachedRectHeight - HITKEY_BASE * uiScale / 2);
      cachedJudgeLineInternal = cachedJudgeLineCss / cachedScaleY;
      updateHitbarPosition();
      positionPauseButton();
    }

    function getCanvasRect(){ return { height: __layoutFrozen ? __frozenRectHeight : cachedRectHeight }; }
    function getScaleY(){ return __layoutFrozen ? __frozenScaleY : cachedScaleY; }
    function getJudgeLineYCss(){ return __layoutFrozen ? __frozenJudgeCss : cachedJudgeLineCss; }
    function getJudgeLineYInternal(){ return getJudgeLineYCss() / getScaleY(); }

    // éŠæˆ²ç‹€æ…‹
    const keys = ['d','f','j','k'];
    const laneDirs = ['left','down','up','right'];

    // æ”¯æ´ DFJK + æ–¹å‘éµ
    function laneFromKey(k) {
      switch (k) {
        case 'd': case 'arrowleft':  return 0;
        case 'f': case 'arrowdown':  return 1;
        case 'j': case 'arrowup':    return 2;
        case 'k': case 'arrowright': return 3;
        default: return null;
      }
    }

    let score = 0, combo = 0, lastJudgementText = '-';
    let startTime = 0, running = false, paused = false, loopId = null;
    let chart = [], comboFlash = '';
    let elapsedTimeBeforePause = 0;
    let nowT = 0, prevTs = 0;

    const hitSound = document.getElementById('hitSound');
    const bgm = document.getElementById('bgm');

    let baseNoteSpeed = 550;
    let noteSpeed = baseNoteSpeed;

    // æ“´å¤§åˆ¤å®šçª—ï¼ˆåŸæœ¬ sick 70/good118/bad123/shit138ï¼‰
    const FNF_WINDOWS = { sick: 80, good: 130, bad: 150, shit: 170 };
    const FNF_SCORES  = { sick: 350, good: 200, bad: 100, shit: -50, miss: -300, ghost: -150 };
    const MISS_Y_OFFSET = 40;
    const TOUCH_WINDOW_MS = FNF_WINDOWS.shit;
    const LATE_MISS_GRACE_MS = 160;

    // çµ±è¨ˆ
    let missCount = 0;
    let gameOver = false;
    let stats = { sick:0, good:0, bad:0, shit:0, miss:0 };

    // ç•¶å‰è³‡è¨Š
    let currentSongTitle = '-';
    let currentDifficulty = 'normal';
    let currentDirection = 'down';
    let currentJudgeMode = 'old';

    // éŸ³æ¨‚é¸æ“‡ï¼ˆå¿…é¸ï¼‰
    let selectedSongFile = null;

    // æ›²åº«ï¼ˆè«‹ç¢ºä¿ /music æª”åä¸€è‡´ï¼‰
    const SONGS = [
      "Charlie Puth - Light Switch [Official Music Video] - Charlie Puth.mp3",
      "Creepy Nuts - ã‚ªãƒˆãƒã‚±(Otonoke) ã€Official MVã€‘ [Dandandan OP] - Creepy Nuts.mp3",
      "Creepy Nuts â€Mirageâ€ Ã— Anime â€Call of the Nightâ€ Collaboration Music Video Opening Theme Song - Creepy Nuts.mp3",
      "Creepy Nuts â€Nemureâ€ Ã— Anime â€Call of the Nightâ€ Collaboration Music Video Ending Theme Song - Creepy Nuts (1).mp3",
      "Creepy Nutsï½¢Bling-Bang-Bang-Bornï½£ Ã— TV Animeï½¢ãƒãƒƒã‚·ãƒ¥ãƒ«-MASHLE-ï½£ Collaboration Music Video #BBBBãƒ€ãƒ³ã‚¹ - Creepy Nuts.mp3",
      "KANA-BOON - Silhouette - KANABOONVEVO.mp3",
      "Lost Sky - Fearless pt.II (feat. Chris Linton) Trap NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky - Vision pt. II (feat. She Is Jules) Future Trap NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky - Where We Started (feat. Jex) Melodic Dubstep NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky, Sara Skinner - Dreams pt. II (feat. Sara Skinner) [NCS Release].mp3",
      "OneRepublic - Nobody (from Kaiju No. 8) [Official Music Video] - OneRepublicVEVO.mp3",
      "YOASOBIã€ŒWatch me!ã€Official Music Video - Ayase _ YOASOBI.mp3",
      "yung kai - blue (official music video) - yung kai.mp3",
      "ã€AKASAKIã€‘Bunny Girl _ ãƒãƒ‹ãƒ¼ã‚¬ãƒ¼ãƒ«ï¼ˆLyric Videoï¼‰ - AKASAKI (19).mp3",
      "ã€MVã€‘éš™_ã‚†ãƒ¼ã‚Šã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã€‘ - ã‚†ãƒ¼ã‚ŠğŸğŸ¥ã€”24ã€•ãƒ»yuri (1).mp3",
      "ã€imaseã€‘NIGHT DANCERï¼ˆMVï¼‰ - imase.mp3",
      "ã€ã‚ªãƒªã‚¸ãƒŠãƒ«æ¨‚æ›²ã€‘ç²›è–!! ãƒ­ãƒªç¥ãƒ¬ã‚¯ã‚¤ã‚¨ãƒ â˜† _ ã—ãã‚Œã†ã„ï¼ˆ9ã•ã„ï¼‰ã€IOSYSï¼ˆã¾ã‚ã‚“&D.wattï¼‰ã€‘ - ã—ãã‚Œã†ã„.mp3",
      "ãªã¨ã‚Š - Overdose - ãªã¨ã‚Š _ natori.mp3",
      "ãƒ­ã‚¯ãƒ‡ãƒŠã‚·ã€ŒãŸã è²ä¸€ã¤ã€_ Rokudenashi - One Voiceã€Official Music Videoã€‘ - ãƒ­ã‚¯ãƒ‡ãƒŠã‚· _ Rokudenashi.mp3",
      "å¥½ãã ã‹ã‚‰ã€‚_ ã€ãƒ¦ã‚¤ã‚«ã€ã€MVã€‘ - ã€ãƒ¦ã‚¤ã‚«ã€.mp3",
      "å»»å»»å¥‡è­š - Eve MV - Eve.mp3",
      "Toge Toge Sadistic - Enormita (youtube).mp3",
      "My dream girls - NACHERRY (youtube).mp3",
      "é’ã®ã™ã¿ã‹ _ ã‚­ã‚¿ãƒ‹ã‚¿ãƒ„ãƒ¤ - Where Our Blue Is _ Tatsuya Kitani - ã‚­ã‚¿ãƒ‹ã‚¿ãƒ„ãƒ¤ _ Tatsuya Kitani.mp3"
    ];

    /* ====== ç•«é¢åˆ‡æ› ====== */
    function showOnly(id) {
      const ids = ['menuScreen','musicScreen','optionsScreen','gameScreen','pauseScreen','endScreen'];
      ids.forEach(x => document.getElementById(x).style.display = (x===id ? 'block' : 'none'));
      if (id !== 'gameScreen') document.getElementById('gameScreen').classList.remove('blur');
    }
    function goToMenu() {
      cancelCountdown();
      stopGameLoop();
      stopAndResetBgm();
      unfreezeLayout();  // å›é¸å–®è§£é™¤å‡çµ
      showOnly('menuScreen');
      phase = 'menu';
      document.body.classList.remove('ex-mode');
      document.getElementById('menuChosenSong').textContent = selectedSongFile ? selectedSongFile.replace(/\.mp3$/i,'') : 'å°šæœªé¸æ“‡';
    }
    function showOptions() { showOnly('optionsScreen'); }
    function showMusic() { showOnly('musicScreen'); }

    // é€²ç«™å°±æŠŠæ›²ç›®æ¸…å–®å¡«å¥½
    function fillSongList() {
      const sel = document.getElementById('songSelect');
      if (sel.dataset.filled) return;
      sel.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'â€” è«‹é¸æ“‡æ›²ç›® â€”';
      placeholder.disabled = true;
      placeholder.selected = !selectedSongFile;
      sel.appendChild(placeholder);
      SONGS.forEach((f) => {
        const opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f.replace(/\.mp3$/i,'');
        if (selectedSongFile === f) opt.selected = true;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', () => {
        document.getElementById('chosenSongLabel').textContent = sel.value ? sel.options[sel.selectedIndex].textContent : 'å°šæœªé¸æ“‡';
      });
      sel.dataset.filled = '1';
    }

    function confirmSong() {
      const sel = document.getElementById('songSelect');
      if (!sel.value) { alert('è«‹å…ˆé¸æ“‡éŸ³æ¨‚'); return; }
      selectedSongFile = sel.value;
      document.getElementById('chosenSongLabel').textContent = sel.options[sel.selectedIndex].textContent;
      document.getElementById('menuChosenSong').textContent = sel.options[sel.selectedIndex].textContent;
      goToMenu();
    }

    /* ====== HUD ====== */
    function updateHUD() {
      document.getElementById('score').textContent = score;
      document.getElementById('combo').textContent = combo;
      document.getElementById('judgement').textContent = lastJudgementText;
      document.getElementById('missCount').textContent = missCount;
      document.getElementById('songTitle').textContent = currentSongTitle;
      document.getElementById('diffLabel').textContent = currentDifficulty.toUpperCase();
      document.getElementById('dirLabel').textContent = (currentDirection === 'up' ? 'ä¸Šå‡' : 'ä¸‹è½');
      document.getElementById('judgeLabel').textContent = (currentJudgeMode === 'old' ? 'Old' : 'New');
    }

    /* ====== è¦–è¦ºï¼ˆç¾ä»£é¢¨ç®­é ­ & æ•ˆæœï¼‰ ====== */
    const laneColors = ['#b266ff', '#66ccff', '#66ff66', '#ff6666'];
    const receptorPulse = [0,0,0,0];
    const hitFx = [];

    function colorLerp(a, b, t){
      const pa = parseInt(a.slice(1),16), pb = parseInt(b.slice(1),16);
      const ar=(pa>>16)&255, ag=(pa>>8)&255, ab=pa&255;
      const br=(pb>>16)&255, bg=(pb>>8)&255, bb=pb&255;
      const r=Math.round(ar+(br-ar)*t), g=Math.round(ag+(bg-ag)*t), b2=Math.round(ab+(bb-ab)*t);
      return `rgb(${r},${g},${b2})`;
    }
    function dirToAngle(dir){
      switch(dir){ case 'up': return 0; case 'down': return Math.PI; case 'left': return -Math.PI/2; case 'right': return Math.PI/2; }
      return 0;
    }
    function drawArrow(x, y, size, dir, baseColor, glow = 1, innerScale = 0.7){
      const angle = dirToAngle(dir);
      const Hh = size * 1.15, Wd = size, headH = Hh * 0.55;

      const drawShape = (scale=1, fillStyle=baseColor, strokeStyle='#000', shadow=0)=>{
        ctx.save(); ctx.translate(x, y); ctx.rotate(angle); ctx.scale(scale, scale);
        if (shadow>0){ ctx.shadowColor = baseColor; ctx.shadowBlur = shadow; }
        ctx.beginPath();
        ctx.moveTo(0, -Hh/2);
        ctx.lineTo(Wd/2, -Hh/2 + headH);
        ctx.lineTo(Wd*0.22, -Hh/2 + headH);
        ctx.lineTo(Wd*0.22,  Hh/2);
        ctx.lineTo(-Wd*0.22, Hh/2);
        ctx.lineTo(-Wd*0.22, -Hh/2 + headH);
        ctx.lineTo(-Wd/2, -Hh/2 + headH);
        ctx.closePath();
        const grad = ctx.createLinearGradient(0, -Hh/2, 0, Hh/2);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.25, colorLerp('#ffffff', baseColor, .2));
        grad.addColorStop(1, baseColor);
        ctx.fillStyle = (fillStyle === 'gradient') ? grad : fillStyle;
        ctx.fill();
        ctx.lineWidth = 6; ctx.strokeStyle = strokeStyle; ctx.stroke();
        ctx.restore();
      };
      drawShape(1.0, 'gradient', '#000000', 16*glow);
      drawShape(innerScale, 'gradient', colorLerp(baseColor,'#ffffff',0.25), 6*glow);
    }
    function drawRing(x,y,r,alpha){
      if (__useLowQuality) return;
      ctx.save(); ctx.globalAlpha = alpha;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
      ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 3; ctx.stroke();
      ctx.restore();
    }
    function flashKeyByLane(laneIdx) { receptorPulse[laneIdx] = 1; }

    /* === Sprite: é æ¸²æŸ“ç®­é ­/æ¥æ”¶å™¨ï¼ˆé¿å…å¶ç™¼é»‘é‚Šæ¶ˆå¤±æŠ–å‹•ï¼‰ === */
    function drawArrowTo(ct, x, y, size, dir, baseColor, glow = 1, innerScale = 0.7){
      const angle = dirToAngle(dir);
      const Hh = size * 1.15, Wd = size, headH = Hh * 0.55;
      const drawShape = (scale=1, fillStyle=baseColor, strokeStyle='#000', shadow=0)=>{
        ct.save(); ct.translate(x, y); ct.rotate(angle); ct.scale(scale, scale);
        if (shadow>0){ ct.shadowColor = baseColor; ct.shadowBlur = shadow; }
        ct.beginPath();
        ct.moveTo(0, -Hh/2);
        ct.lineTo(Wd/2, -Hh/2 + headH);
        ct.lineTo(Wd*0.22, -Hh/2 + headH);
        ct.lineTo(Wd*0.22,  Hh/2);
        ct.lineTo(-Wd*0.22, Hh/2);
        ct.lineTo(-Wd*0.22, -Hh/2 + headH);
        ct.lineTo(-Wd/2, -Hh/2 + headH);
        ct.closePath();
        const grad = ct.createLinearGradient(0, -Hh/2, 0, Hh/2);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.25, colorLerp('#ffffff', baseColor, .2));
        grad.addColorStop(1, baseColor);
        ct.fillStyle = grad; ct.fill();
        ct.lineWidth = 6; ct.strokeStyle = '#000'; ct.stroke();
        ct.restore();
      };
      drawShape(1.0, 'gradient', '#000000', 16*glow);
      drawShape(innerScale, 'gradient', colorLerp(baseColor,'#ffffff',0.25), 6*glow);
    }
    function __makeArrowSprite(size, dir, baseColor, opts){
      const glow = opts.glow ?? 1;
      const innerScale = opts.innerScale ?? 0.7;
      const pad = Math.ceil(size*1.6 + 18*glow);
      const dpr = Math.min(2, window.devicePixelRatio||1);
      const off = document.createElement('canvas');
      off.width = off.height = pad*2*dpr;
      const octx = off.getContext('2d', { alpha:true });
      octx.scale(dpr, dpr);
      if (opts.low){
        const angle = dirToAngle(dir);
        const Hh = size * 1.15, Wd = size, headH = Hh * 0.55;
        octx.save(); octx.translate(pad, pad); octx.rotate(angle);
        octx.beginPath();
        octx.moveTo(0, -Hh/2);
        octx.lineTo(Wd/2, -Hh/2 + headH);
        octx.lineTo(Wd*0.22, -Hh/2 + headH);
        octx.lineTo(Wd*0.22,  Hh/2);
        octx.lineTo(-Wd*0.22, Hh/2);
        octx.lineTo(-Wd*0.22, -Hh/2 + headH);
        octx.lineTo(-Wd/2, -Hh/2 + headH);
        octx.closePath();
        const grad = octx.createLinearGradient(0, -Hh/2, 0, Hh/2);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(1, baseColor);
        octx.fillStyle = grad; octx.fill();
        octx.lineWidth = 3; octx.strokeStyle = '#000'; octx.stroke();
        octx.restore();
      } else {
        drawArrowTo(octx, pad, pad, size, dir, baseColor, glow, innerScale);
      }
      return { canvas: off, half: pad, size: pad*2 };
    }
    const __SPR = { noteHQ:[], recHQ:[], noteLQ:[], recLQ:[] };
    function __buildSprites(){
      for (let i=0;i<4;i++){
        const dir = laneDirs[i], col = laneColors[i];
        __SPR.noteHQ[i] = __makeArrowSprite(NOTE_BASE, dir, col, { glow: 0.8, innerScale: 0.7 });
        __SPR.recHQ[i]  = __makeArrowSprite(NOTE_BASE, dir, col, { glow: 1.0, innerScale: 0.7 });
        __SPR.noteLQ[i] = __makeArrowSprite(NOTE_BASE, dir, col, { low:true });
        __SPR.recLQ[i]  = __makeArrowSprite(NOTE_BASE, dir, col, { low:true });
      }
    }
    function __drawSprite(sp, x, y, scale=1){
      ctx.save(); ctx.translate(x,y); ctx.scale(scale,scale);
      ctx.drawImage(sp.canvas, -sp.half, -sp.half, sp.size, sp.size);
      ctx.restore();
    }

    /* === Perf: FPS monitor & remain counter === */
    let __fpsMA = 60, __fpsFrames = 0, __fpsLastTs = 0;
    let __useLowQuality = false;
    let __remainNotes = 0;

    function __trackFPS(ts){
      __fpsFrames++;
      if(!__fpsLastTs){ __fpsLastTs = ts; return; }
      const span = ts - __fpsLastTs;
      if (span >= 300){
        const inst = __fpsFrames * 1000 / span;
        __fpsMA = __fpsMA * 0.8 + inst * 0.2;
        __fpsFrames = 0; __fpsLastTs = ts;
        if (__fpsMA < 54) __useLowQuality = true;
        else if (__fpsMA > 58) __useLowQuality = false;
      }
    }

    /* ====== åˆ¤å®š ====== */
    function judge(dtMs, lane) {
      const adt = Math.abs(dtMs);
      let rating = '', scoreDelta = 0;
      if (adt <= FNF_WINDOWS.sick)      { rating = 'SICK!'; scoreDelta = FNF_SCORES.sick; stats.sick++; combo++; }
      else if (adt <= FNF_WINDOWS.good) { rating = 'GOOD';  scoreDelta = FNF_SCORES.good; stats.good++; combo++; }
      else if (adt <= FNF_WINDOWS.bad)  { rating = 'BAD';   scoreDelta = FNF_SCORES.bad;  stats.bad++;  combo++; }
      else if (adt <= FNF_WINDOWS.shit) { rating = 'SHIT';  scoreDelta = FNF_SCORES.shit; stats.shit++; combo = Math.max(0, combo-1); }
      else { miss(); return; }
      score = Math.max(0, score + scoreDelta);
      lastJudgementText = rating;
      receptorPulse[lane] = 1;
      hitFx.push({lane, t0: nowT, life: 0.25});
      updateHUD();
      if (combo > 0 && combo % 10 === 0) {
        comboFlash = `COMBO x${combo}!!`;
        setTimeout(() => comboFlash = '', 800);
      }
    }
    function miss() {
      lastJudgementText = 'MISS';
      combo = 0; missCount++; stats.miss++;
      score = Math.max(0, score + FNF_SCORES.miss);
      updateHUD();
      if (currentDifficulty === 'ex' && missCount > 15) triggerFailOnce('ä½ è¼¸äº†ï¼EX æ¨¡å¼ MISS è¶…é 15 æ¬¡');
    }
    function ghostTap(lane) {
      lastJudgementText='MISS'; combo=0;
      score=Math.max(0, score+FNF_SCORES.ghost);
      receptorPulse[lane]=0.5; updateHUD();
    }
    function triggerFailOnce(msg) {
      if (gameOver) return; gameOver = true; running = false;
      stopGameLoop(); stopAndResetBgm();
      setTimeout(() => { alert(msg); goToMenu(); }, 0);
    }

    /* ====== è‡ªå‹•ç”Ÿè­œï¼ˆåŸç‰ˆé›£åº¦ï¼‰ ====== */
    function generateChart(durationSec) {
      chart = [];
      const difficulty = currentDifficulty;
      let doubleNoteChance = 0.35;
      let timeGapMin = 0.20;
      let timeGapMax = 0.45;
      if (difficulty === 'beginner')      { doubleNoteChance = 0.15; timeGapMin = 0.30; timeGapMax = 0.60; }
      else if (difficulty === 'easy')     { doubleNoteChance = 0.20; timeGapMin = 0.25; timeGapMax = 0.50; }
      else if (difficulty === 'normal')   { doubleNoteChance = 0.35; timeGapMin = 0.20; timeGapMax = 0.45; }
      else if (difficulty === 'hard')     { doubleNoteChance = 0.55; timeGapMin = 0.15; timeGapMax = 0.35; }

      if (!(difficulty === 'ex' || difficulty === 'hell')) {
        let time = 1;
        while (time < durationSec) {
          const lanesUsed = new Set();
          const notesThisFrame = [];
          const count = Math.random() < doubleNoteChance ? 2 : 1;
          while (notesThisFrame.length < count) {
            const lane = Math.floor(Math.random() * 4);
            if (!lanesUsed.has(lane)) {
              lanesUsed.add(lane);
              notesThisFrame.push({ t: time, lane, type: 'tap', hit: false, y: -50 });
            }
          }
          chart.push(...notesThisFrame);
          time += Math.random() * (timeGapMax - timeGapMin) + timeGapMin;
        }
        __remainNotes = chart.length;
        return;
      }

      // EX / HELLï¼ˆè¼ƒå¯†é›†é‚è¼¯ï¼‰
      const beat = 0.5;
      let t = 1;
      let laneCursor = 0;
      const nextLane = () => { laneCursor = (laneCursor + 1) % 4; return laneCursor; };
      const pushNote = (tt, lane) => chart.push({ t: tt, lane, type: 'tap', hit: false, y: -50 });
      const randLane = () => Math.floor(Math.random() * 4);

      while (t < durationSec) {
        if (difficulty === 'ex') {
          pushNote(t, nextLane());
          if (Math.random() < 0.60) pushNote(t, (laneCursor + 2) % 4);
          if (Math.random() < 0.35) pushNote(t + beat / 2, (laneCursor + 1) % 4);
          if (Math.random() < 0.18) {
            pushNote(t + beat / 3, randLane());
            pushNote(t + 2 * beat / 3, randLane());
          }
          t += Math.random() < 0.5 ? beat / 2 : beat;
        } else { // hell
          pushNote(t, nextLane());
          if (Math.random() < 0.85) pushNote(t, (laneCursor + 2) % 4);
          pushNote(t + beat / 2, (laneCursor + 1) % 4);
          if (Math.random() < 0.4) {
            pushNote(t + beat / 4, randLane());
            pushNote(t + 3 * beat / 4, randLane());
          }
          t += beat / 2;
        }
      }
      __remainNotes = chart.length;
    }

    /* ====== å¹¾ä½• & å‘½ä¸­åˆ¤å®š ====== */
    function noteYAtTimeFor(tHit, tNow) {
      const judge = getJudgeLineYInternal();
      if (currentDirection === 'down') return judge - (tHit - tNow) * noteSpeed;
      return judge + (tHit - tNow) * noteSpeed;
    }
    function isTapMiss(n, currentTimeSec) {
      const judge = getJudgeLineYInternal();
      const dtMs = (currentTimeSec - n.t) * 1000;
      const beyondDown = n.y > judge + MISS_Y_OFFSET;
      const beyondUp = n.y < judge - MISS_Y_OFFSET;
      const graceOver = dtMs > LATE_MISS_GRACE_MS;
      return (currentDirection === 'down') ? (beyondDown && graceOver) : (beyondUp && graceOver);
    }

    /* ====== æ›´æ–° & ç¹ªåœ– ====== */
    function updateHitbarPosition() {
      if (!hitbar || document.getElementById('gameScreen').style.display === 'none') return;
      const topPx = getJudgeLineYCss() - (HITKEY_BASE * uiScale / 2);
      hitbar.style.top = `${topPx}px`;
    }

    function positionPauseButton() {
      const btn = document.getElementById('pauseButton');
      if (!btn) return;
      btn.classList.remove('pause-bottom');
      const isCoarse = window.matchMedia('(pointer: coarse)').matches;
      if (isCoarse && currentDirection === 'up') {
        btn.classList.add('pause-bottom');
      }
    }

    function update(t, dt) {
      for (let i=0;i<chart.length;i++){
        const n = chart[i];
        n.y = noteYAtTimeFor(n.t, t);
      }
      for (let i=0;i<chart.length;i++){
        const n = chart[i];
        if (!n.hit && isTapMiss(n, t)) { n.hit = true; __remainNotes--; miss(); }
      }
      for (let i=0;i<4;i++) receptorPulse[i] = Math.max(0, receptorPulse[i] - dt*3.2);
      for (let i = hitFx.length-1; i>=0; i--) if (t - hitFx[i].t0 > hitFx[i].life) hitFx.splice(i,1);
    }

    function render({skipNotes=false} = {}) {
      const judge = getJudgeLineYInternal();
      ctx.clearRect(0, 0, W, H);

      // receptor
      const _rec = __useLowQuality ? __SPR.recLQ : __SPR.recHQ;
      for (let lane=0; lane<4; lane++){
        const x = lane * laneWidth + laneWidth / 2;
        const pulse = receptorPulse[lane];
        const s = 1 + 0.18 * pulse;
        __drawSprite(_rec[lane], x, judge, s);
      }

      // notesï¼ˆè¦–çª—è£å‰ªï¼‰
      if (!skipNotes) {
        const _note = __useLowQuality ? __SPR.noteLQ : __SPR.noteHQ;
        const top = -120, bottom = H + 120;
        for (let i=0;i<chart.length;i++){
          const n = chart[i];
          if (n.hit) continue;
          if (n.y < top || n.y > bottom) continue;
          const x = n.lane * laneWidth + laneWidth / 2;
          __drawSprite(_note[n.lane], x, n.y, 1);
        }
      }

      // å‘½ä¸­å¤–åœˆ
      for (let i=0;i<hitFx.length;i++){
        const fx = hitFx[i];
        const p = Math.min(1, (nowT - fx.t0) / fx.life);
        const x = fx.lane * laneWidth + laneWidth / 2;
        drawRing(x, judge, 18 + 80*p, 1 - p);
      }

      // åˆ¤å®šæ–‡å­—
      if (lastJudgementText !== '-') {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        const offset = (currentDirection === 'up') ? 120 : -40;
        ctx.fillText(lastJudgementText, W / 2, judge + offset);
      }

      if (comboFlash) {
        ctx.fillStyle = '#ff78b5';
        ctx.font = 'bold 36px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(comboFlash, W / 2, H / 2 - 100);
      }
    }

    // åœ¨æŒ‡å®šæ™‚é–“ t é è¦½å ´ä¸ŠéŸ³ç¬¦ï¼ˆä¸æ”¹è®Šä»»ä½•ç‹€æ…‹ã€ä¸åˆ¤å®šã€ä¸è¨ˆ MISSï¼‰
    function renderPreviewAt(t) {
      const judge = getJudgeLineYInternal();
      ctx.clearRect(0, 0, W, H);

      const _rec = __useLowQuality ? __SPR.recLQ : __SPR.recHQ;
      for (let lane = 0; lane < 4; lane++) {
        const x = lane * laneWidth + laneWidth / 2;
        __drawSprite(_rec[lane], x, judge, 1);
      }

      const _note = __useLowQuality ? __SPR.noteLQ : __SPR.noteHQ;
      const top = -120, bottom = H + 120;
      for (let i = 0; i < chart.length; i++) {
        const n = chart[i];
        if (n.hit) continue;
        const y = noteYAtTimeFor(n.t, t);
        if (y < top || y > bottom) continue;
        const x = n.lane * laneWidth + laneWidth / 2;
        __drawSprite(_note[n.lane], x, y, 1);
      }
    }

    function endGameAndShowResult(){
      running = false;
      lastJudgementText = 'END';
      updateHUD();
      document.getElementById('finalSong').textContent = currentSongTitle;
      document.getElementById('finalDiff').textContent = currentDifficulty.toUpperCase();
      document.getElementById('finalDir').textContent  = (currentDirection === 'up' ? 'ä¸Šå‡' : 'ä¸‹è½');
      document.getElementById('finalJudge').textContent= (currentJudgeMode === 'old' ? 'Old' : 'New');
      document.getElementById('finalScore').textContent = score;
      document.getElementById('statSick').textContent = stats.sick;
      document.getElementById('statGood').textContent = stats.good;
      document.getElementById('statBad').textContent = stats.bad;
      document.getElementById('statShit').textContent = stats.shit;
      document.getElementById('statMiss').textContent = stats.miss;
      showOnly('endScreen');
      phase = 'menu';
    }

    let songEnded = false;

    function loop(ts) {
      if (paused) return;
      if (!prevTs) { prevTs = ts; __lastRenderTs = ts; }
      nowT = (ts - startTime) / 1000;
      const dt = Math.max(0, (ts - prevTs) / 1000);
      prevTs = ts;

      update(nowT, dt);
      __trackFPS(ts);

      // æ‰‹æ©Ÿç©©å®š 60fps çš„è¦–è¦ºç¯€å¥é–ï¼ˆä¸å½±éŸ¿åˆ¤å®šæ™‚é–“ï¼‰
      let doRender = true;
      if (__fpsMode === 'stable60' && IS_MOBILE) {
        if (ts - __lastRenderTs < __TARGET_INTERVAL - 0.5) {
          doRender = false;
        } else {
          const steps = Math.max(1, Math.floor((ts - __lastRenderTs) / __TARGET_INTERVAL));
          __lastRenderTs += steps * __TARGET_INTERVAL;
        }
      }
      if (doRender) render();

      if (songEnded || __remainNotes <= 0) {
        endGameAndShowResult();
        return;
      }

      loopId = requestAnimationFrame(loop);
    }
    function stopGameLoop(){ try{ cancelAnimationFrame(loopId); }catch{} loopId=null; prevTs=0; }

    /* ====== å€’æ•¸è™•ç†ï¼ˆå¯ä¸­æ­¢ + å¯é è¦½ï¼‰ ====== */
    function showCountdown(startCallback, opts) {
      cancelCountdown();
      isCountingDown = true;
      phase = 'countdown';

      // å¯é¸ï¼šopts = { showNotes: true, previewTime: <number ç§’> }
      const previewTime = opts && typeof opts.previewTime === 'number' ? opts.previewTime : null;
      const showNotes = !!(opts && opts.showNotes && previewTime !== null);

      const countdownLoop = () => {
        if (!isCountingDown) return;
        if (showNotes) { renderPreviewAt(previewTime); }
        else { render({skipNotes:true}); }
        countdownRAF = requestAnimationFrame(countdownLoop);
      };
      countdownLoop();

      const el = document.getElementById('countdownText');
      el.style.display = 'block';
      const steps = ['Ready', '3', '2', '1', 'Go!'];
      const stepDur = 700;

      const playStep = (i) => {
        if (!isCountingDown) return;
        el.textContent = steps[i];
        el.style.animation = 'none';
        void el.offsetWidth;
        el.style.animation = 'popScale .55s ease-out';
      };

      for (let i=0;i<steps.length;i++){
        countdownTimers.push(setTimeout(()=>playStep(i), i*stepDur));
      }
      countdownTimers.push(setTimeout(()=>{
        if (!isCountingDown) return;
        el.style.display = 'none';
        isCountingDown = false;
        try { cancelAnimationFrame(countdownRAF); } catch {}
        startCallback();
      }, steps.length*stepDur));
    }

    function cancelCountdown() {
      if (!isCountingDown && countdownTimers.length===0 && !countdownRAF) return;
      isCountingDown = false;
      countdownTimers.forEach(id=>clearTimeout(id));
      countdownTimers = [];
      try{ cancelAnimationFrame(countdownRAF); }catch{}
      countdownRAF = null;
      const el = document.getElementById('countdownText');
      el.style.animation = 'none';
      el.style.display = 'none';
    }

    function stopAndResetBgm(){
      try { bgm.pause(); } catch {}
      try { bgm.currentTime = 0; } catch {}
      stopPlayGuard();
    }

    /* ====== éŸ³æ•ˆ/éŸ³é‡/æ’­æ”¾å®ˆè­· ====== */
    const warnBanner = document.getElementById('warnBanner');
    let audioWarned = false;
    let _playGuardTimer = null;

    function setVolumes(percent){
      const v = Math.max(0, Math.min(100, percent)) / 100;
      bgm.volume = v;
      hitSound.volume = Math.min(1, v * 0.9); // é˜è²ç•¥å°
    }
    function initVolumeUI(){
      const slider = document.getElementById('volumeSlider');
      const label  = document.getElementById('volumeLabel');
      const saved = +localStorage.getItem('dfjk.volume') || 80;
      slider.value = String(saved);
      label.textContent = `${saved}%`;
      setVolumes(saved);
      slider.addEventListener('input', ()=>{
        const val = +slider.value;
        label.textContent = `${val}%`;
        setVolumes(val);
        localStorage.setItem('dfjk.volume', String(val));
      });
    }

    function playTapSound(){
      try { hitSound.currentTime = 0; hitSound.play().catch(()=>{}); } catch {}
    }

    function showPlayWarning(msg){
      if (audioWarned) return;
      audioWarned = true;
      warnBanner.textContent = msg || 'âš ï¸ éŸ³æ¨‚ç„¡æ³•æ’­æ”¾ï¼šè«‹ç¢ºèªæª”å/è·¯å¾‘ï¼Œæˆ–é»ä¸€ä¸‹ç•«é¢å†æŒ‰é–‹å§‹ã€‚';
      warnBanner.style.display = 'block';
      setTimeout(()=>{ warnBanner.style.display = 'none'; audioWarned=false; }, 3000);
    }

    function guardAudioPlayback(){
      stopPlayGuard();
      const t0 = bgm.currentTime;
      _playGuardTimer = setTimeout(()=>{
        const advanced = bgm.currentTime > t0 + 0.05;
        if (bgm.paused || !advanced) showPlayWarning();
      }, 1500);
    }
    function stopPlayGuard(){
      if (_playGuardTimer){ clearTimeout(_playGuardTimer); _playGuardTimer = null; }
    }

    /* ====== è¼¸å…¥ï¼ˆéµç›¤ï¼‹è§¸æ§ï¼‰ ====== */
    window.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      const lane = laneFromKey(k);

      if (lane !== null) {
        if (phase === 'playing') onLanePress(lane);
        e.preventDefault();
        return;
      }

      if (e.key === 'Escape') {
        if (phase === 'countdown') {
          cancelCountdown();
          goToMenu();
          return;
        }
        if (phase === 'playing') { paused ? resumeGame() : pauseGame(); return; }
        if (phase === 'paused')  { resumeGame(); return; }
      }
    });

    canvas.addEventListener('pointerdown', (e) => {
      if (phase !== 'playing') return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const cssLaneWidth = rect.width / 4;
      const lane = Math.min(3, Math.max(0, Math.floor(x / cssLaneWidth)));
      onLanePress(lane);
    }, { passive:false });

    function onLanePress(lane) {
      if (!running) return;

      // é˜è²ï¼šå‘½ä¸­æˆ–ç©ºæ‰“éƒ½è¦æœ‰ï¼ˆçµ±ä¸€åœ¨é€™è£¡æ’­ï¼Œé¿å…é‡è¤‡ï¼‰
      playTapSound();

      const tNow = (performance.now() - startTime) / 1000;
      let bestIdx = -1, bestAbs = Infinity;

      for (let i = 0; i < chart.length; i++) {
        const n = chart[i];
        if (n.hit || n.lane !== lane) continue;
        const dtMs = (tNow - n.t) * 1000;
        const adt = Math.abs(dtMs);
        if (adt <= TOUCH_WINDOW_MS && adt < bestAbs) { bestAbs = adt; bestIdx = i; }
      }

      if (bestIdx >= 0) {
        const n = chart[bestIdx];
        judge((tNow - n.t) * 1000, lane);
        n.hit = true;
        __remainNotes--;
        flashKeyByLane(lane);
      } else {
        if (currentJudgeMode === 'old') ghostTap(lane);
        flashKeyByLane(lane);
      }
    }

    /* ====== æµç¨‹ ====== */
    function startGame() {
      if (!selectedSongFile) { alert('è«‹å…ˆé¸æ“‡éŸ³æ¨‚'); showMusic(); return; }

      const difficulty = document.getElementById('difficultySelect').value;
      const speedMultiplierSelect = document.getElementById('speedMultiplier');
      const dir = document.getElementById('noteDirection').value;
      const jmode = document.getElementById('judgeMode').value;
      currentDifficulty = difficulty;
      currentDirection  = dir;
      currentJudgeMode  = jmode;

      let multiplier = parseFloat(speedMultiplierSelect.value);
      if      (difficulty === 'beginner') multiplier = 0.8;
      else if (difficulty === 'easy')     multiplier = 0.9;
      else if (difficulty === 'ex')       multiplier = 1.8;
      noteSpeed = baseNoteSpeed * multiplier;

      document.body.classList.toggle('ex-mode', difficulty === 'ex');

      // é‡ç½®ç‹€æ…‹
      stopGameLoop();
      score = 0; combo = 0; lastJudgementText = '-'; comboFlash = '';
      chart = []; paused = false; running = true; missCount = 0; gameOver = false;
      stats = { sick:0, good:0, bad:0, shit:0, miss:0 };
      elapsedTimeBeforePause = 0; nowT = 0; prevTs = 0;
      for (let i=0;i<4;i++) receptorPulse[i]=0;
      hitFx.length = 0;
      updateHUD();

      currentSongTitle = selectedSongFile.replace(/\.mp3$/i, '');
      const url = 'music/' + encodeURIComponent(selectedSongFile);
      bgm.src = url; bgm.load();

      // è¿½è¹¤éŸ³æ¨‚çµæŸ
      songEnded = false;
      bgm.onended = () => { songEnded = true; stopPlayGuard(); };

      showOnly('gameScreen');
      phase = 'countdown';

      applyDesktopScale();
      recomputeLayout();
      updateHUD();
      __lastRenderTs = 0;

      // æº–å‚™è­œé¢
      let chartFinalized = false;
      generateChart(120);
      bgm.onloadedmetadata = () => {
        if (chartFinalized) return;
        const durationSec = (!isNaN(bgm.duration) && bgm.duration > 0) ? bgm.duration : 120;
        generateChart(durationSec);
        chartFinalized = true;
      };

      // å»ºç«‹ spritesï¼ˆä¸€æ¬¡æ€§ï¼‰
      __buildSprites();

      // é–‹å±€å€’æ•¸ï¼ˆç¶­æŒåŸæœ¬åªé¡¯ç¤º receptorï¼‰
      showCountdown(() => {
        if (phase !== 'countdown') return;
        phase = 'playing';
        freezeLayout();     // é€²é—œå³å›ºå®šå¹¾ä½•
        startTime = performance.now();
        try {
          const p = bgm.play();
          if (p && typeof p.catch === 'function') p.catch(()=>showPlayWarning());
        } catch {}
        guardAudioPlayback();
        loopId = requestAnimationFrame(loop);
      });
    }

    function pauseGame() {
      if (phase === 'countdown') {
        cancelCountdown();
        goToMenu();
        return;
      }
      if (!running || paused) return;
      paused = true;
      phase = 'paused';
      try { bgm.pause(); } catch {}
      stopPlayGuard();
      stopGameLoop();
      elapsedTimeBeforePause = (performance.now() - startTime) / 1000;
      unfreezeLayout();   // æš«åœè§£é™¤å‡çµï¼Œå…è¨±è¦–çª—èª¿æ•´
      document.getElementById('gameScreen').classList.add('blur');
      showOnly('pauseScreen');
    }

    function resumeGame() {
      if (!paused) return;
      paused = false;

      // å…ˆå›åˆ°éŠæˆ²ç•«é¢ï¼Œä½†é€²å…¥å€’æ•¸éšæ®µï¼Œä¸è¦ç«‹åˆ»æ’­æ”¾æˆ–è·‘è¿´åœˆ
      showOnly('gameScreen');
      document.getElementById('gameScreen').classList.remove('blur');

      applyDesktopScale();
      recomputeLayout();

      // é€²å…¥å€’æ•¸æ¨¡å¼ï¼šé¡¯ç¤ºã€Œæš«åœç•¶ä¸‹ã€çš„è­œé¢é è¦½
      phase = 'countdown';
      showCountdown(() => {
        // å€’æ•¸çµæŸæ‰çœŸæ­£æ¢å¾©
        phase = 'playing';
        freezeLayout(); // æ¢å¾©æ™‚å›ºå®šå¹¾ä½•

        // è®“è­œé¢æ™‚é–“é»èˆ‡éŸ³æ¨‚ä¿æŒã€Œæš«åœå‰ã€çš„å°é½Š
        startTime = performance.now() - (elapsedTimeBeforePause * 1000);
        __lastRenderTs = 0;

        try {
          const p = bgm.play();
          if (p && typeof p.catch === 'function') p.catch(() => showPlayWarning());
        } catch {}

        guardAudioPlayback();
        loopId = requestAnimationFrame(loop);
      }, { showNotes: true, previewTime: elapsedTimeBeforePause });
    }

    /* ====== åˆå§‹åŒ– ====== */
    function renderIdle() {
      if (document.getElementById('gameScreen').style.display === 'block') return;
      recomputeLayout();
    }

    function onViewportChanged(){
      if (__layoutFrozen) return; // æ‰“æ­Œä¸­ä¸éŸ¿æ‡‰è¦–çª—è®ŠåŒ–ï¼Œé¿å…ä½ç§»
      if (phase === 'playing' || phase === 'countdown') {
        applyDesktopScale();
        recomputeLayout();
      }
    }

    applyDesktopScale();
    initVolumeUI();
    fillSongList();
    window.addEventListener('resize', onViewportChanged, { passive: true });
    window.addEventListener('scroll', () => { if (!__layoutFrozen && (phase==='playing'||phase==='countdown')) recomputeLayout(); }, { passive: true });
    if (window.visualViewport) {
      ['resize','scroll'].forEach(ev => {
        window.visualViewport.addEventListener(ev, onViewportChanged, { passive: true });
      });
    }
    window.addEventListener('orientationchange', () => {
      unfreezeLayout();
      applyDesktopScale();
      recomputeLayout();
      if (phase === 'playing' || phase === 'countdown') freezeLayout();
    }, { passive: true });

    // åªåœ¨éŠæˆ²éšæ®µæ‰é˜»æ­¢å³éµ/ç¸®æ”¾/é›™æ“Šï¼Œé¿å…åœ¨é¸å–®/é¸é …é æ“ä½œå›æº¯
    document.addEventListener("contextmenu", e => { if (phase==='playing'||phase==='countdown') e.preventDefault(); });
    document.addEventListener('gesturestart', e => { if (phase==='playing'||phase==='countdown') e.preventDefault(); });
    document.addEventListener('dblclick', e => { if (phase==='playing'||phase==='countdown') e.preventDefault(); });

    goToMenu();
  </script>
</body>
</html>



