<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <!-- 行動裝置：關閉縮放、雙擊放大、pinch -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>DFJK 節奏遊戲</title>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
  <style>
    html, body { touch-action: manipulation; }
    body {
      margin: 0; background: #0f1220; color: #fff; font-family: sans-serif;
      text-align: center; transition: background 0.5s ease;
    }
    body.ex-mode { background: linear-gradient(to bottom, #ff3300, #990000, #000000); }

    /* 舞台容器（手機 1.0，桌機用 --u 放大） */
    #stage {
      position: relative;
      width: 95%;
      max-width: 420px;
      margin: 20px auto;
      --u: 1;
    }

    canvas {
      display: block;
      background: #1f2340;
      border: 2px solid #fff;
      width: 100%;
      height: auto;
      touch-action: manipulation;
    }

    /* DOM hitbar 只是定位參考（FNF receptor 改由 canvas 畫） */
    .hitbar {
      position: absolute; left: 0; width: 100%;
      display: flex; justify-content: space-between; align-items: center;
      height: calc(90px * var(--u));
      z-index: 2;
      opacity: 0;
      pointer-events: none;
    }
    .hitkey { flex:1; margin:0 5px; height:calc(90px * var(--u)); }

    .hud { font-size: 18px; margin-top: 10px; line-height: 1.6; }
    .songline { font-size: 14px; opacity: .9; }
    button {
      margin:10px; padding:10px 20px; font-size:18px; background:#78d5ff; border:none; border-radius:8px; cursor:pointer;
    }
    #menuScreen, #musicScreen, #endScreen, #optionsScreen, #pauseScreen { padding-top: 120px; }
    .blur { filter: blur(6px); pointer-events: none; user-select: none; }
    #pauseButton { position: absolute; top: 10px; right: 10px; z-index: 3; }

    /* 倒數文字：移除閃爍的透明度改為純縮放脈衝 */
    #countdownText {
      position: absolute; top: 40%; left: 50%; transform: translate(-50%,-50%);
      font-family: 'Fredoka One', sans-serif; font-size: 72px; color: #fff; text-shadow: 2px 2px 8px #000; z-index: 5;
      pointer-events: none;
      opacity: 1;            /* 全程維持可見，不用 0/1 跳變 */
      will-change: transform;
    }
    @keyframes popScale {
      0%   { transform: translate(-50%,-50%) scale(0.85); }
      50%  { transform: translate(-50%,-50%) scale(1.12); }
      100% { transform: translate(-50%,-50%) scale(1.00); }
    }

    .row { margin: 10px 0; }
    label { margin-right: 6px; }
    select { padding: 6px 10px; border-radius: 6px; border: 1px solid #445; background:#12152a; color:#fff; }

    /* 音樂選單 */
    #songSelect { width: 90%; max-width: 420px; height: 280px; }
    #musicScreen .hint { opacity: .8; font-size: 14px; margin-top: 6px; }
  </style>
</head>
<body>
  <!-- 主選單 -->
  <div id="menuScreen">
    <h1>🎵 DFJK 節奏遊戲</h1>
    <div class="row">
      <button onclick="startGame()">開始遊戲</button>
      <button onclick="showMusic()">音樂</button>
      <button onclick="showOptions()">選項</button>
    </div>
    <div class="row">
      已選曲目：<span id="menuChosenSong">尚未選擇</span>
    </div>
  </div>

  <!-- 音樂選單（必選） -->
  <div id="musicScreen" style="display:none;">
    <h2>🎼 選擇本局曲目</h2>
    <div class="row">
      <select id="songSelect" size="12"></select>
      <div class="hint">必須選擇曲目才可開始。</div>
    </div>
    <div class="row">
      <button onclick="confirmSong()">確定</button>
      <button onclick="goToMenu()">回主選單</button>
    </div>
    <div class="row">
      已選：<span id="chosenSongLabel">尚未選擇</span>
    </div>
  </div>

  <!-- 選項 -->
  <div id="optionsScreen" style="display:none;">
    <h2>⚙️ 遊戲選項</h2>

    <div class="row">
      <label for="difficultySelect">難度：</label>
      <select id="difficultySelect">
        <option value="ex">EX（極限）</option>
        <option value="hell">地獄</option>
        <option value="hard">困難</option>
        <option value="normal" selected>普通</option>
        <option value="easy">簡單</option>
        <option value="beginner">初學者</option>
      </select>
    </div>

    <div class="row">
      <label for="speedMultiplier">速度倍率：</label>
      <select id="speedMultiplier">
        <option value="1">1.0x（標準）</option>
        <option value="1.1">1.1x</option>
        <option value="1.2">1.2x</option>
        <option value="1.3">1.3x</option>
        <option value="1.6">1.6x</option>
        <option value="2.0">2.0x</option>
      </select>
    </div>

    <div class="row">
      <label for="noteDirection">音符方向：</label>
      <select id="noteDirection">
        <option value="down" selected>下落打擊（打擊線在底）</option>
        <option value="up">上升打擊（打擊線在頂）</option>
      </select>
    </div>

    <div class="row">
      <label for="judgeMode">判定模式：</label>
      <select id="judgeMode">
        <option value="old" selected>Old Input（含 Ghost 懲罰）</option>
        <option value="new">New Input（移除 WRONG）</option>
      </select>
    </div>

    <div class="row">
      <button onclick="goToMenu()">回主選單</button>
    </div>
  </div>

  <!-- 遊戲畫面 -->
  <div id="gameScreen" style="display:none; position:relative;">
    <button id="pauseButton" onclick="pauseGame()">⏸️</button>

    <div id="stage">
      <canvas id="gameCanvas" width="420" height="640"></canvas>

      <div class="hitbar">
        <div class="hitkey" id="key-d"></div>
        <div class="hitkey" id="key-f"></div>
        <div class="hitkey" id="key-j"></div>
        <div class="hitkey" id="key-k"></div>
      </div>
    </div>

    <div class="hud">
      分數：<span id="score">0</span>　
      連擊：<span id="combo">0</span>　
      判定：<span id="judgement">-</span>　
      MISS：<span id="missCount">0</span>
      <div class="songline">
        曲目：<span id="songTitle">-</span>　｜　難度：<span id="diffLabel">-</span>　｜　方向：<span id="dirLabel">-</span>　｜　判定：<span id="judgeLabel">-</span>
      </div>
    </div>
  </div>

  <!-- 暫停 -->
  <div id="pauseScreen" style="display:none;">
    <h2>⏸️ 遊戲暫停</h2>
    <button onclick="resumeGame()">▶️ 繼續</button>
    <button onclick="goToMenu()">回主選單</button>
  </div>

  <!-- 結算 -->
  <div id="endScreen" style="display:none;">
    <h2>🎮 遊戲結束！</h2>
    <p>曲目：<span id="finalSong">-</span></p>
    <p>難度：<span id="finalDiff">-</span></p>
    <p>方向：<span id="finalDir">-</span></p>
    <p>判定：<span id="finalJudge">-</span></p>
    <p>分數：<span id="finalScore">0</span></p>
    <p>SICK：<span id="statSick">0</span></p>
    <p>GOOD：<span id="statGood">0</span></p>
    <p>BAD：<span id="statBad">0</span></p>
    <p>SHIT：<span id="statShit">0</span></p>
    <p>MISS：<span id="statMiss">0</span></p>
    <button onclick="startGame()">再玩一次</button>
    <button onclick="goToMenu()">回主選單</button>
  </div>

  <div id="countdownText" style="display:none;"></div>

  <audio id="hitSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_6e3e3b6f3f.mp3?filename=click-124467.mp3"></audio>
  <audio id="bgm"></audio>

  <script>
    /* ========= 參數 ========= */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // 內部遊戲座標（固定 420x640）
    const W = canvas.width, H = canvas.height;
    const laneWidth = W / 4;
    const hitbar = document.querySelector('.hitbar');

    // —— UI 縮放（桌機放大、手機不動） —— //
    const HITKEY_BASE = 90;    // hitbar 高度（基準）
    const NOTE_BASE   = 60;    // 箭頭基準邊
    let uiScale = 1;

    // 狀態機
    let phase = 'menu'; // 'menu' | 'countdown' | 'playing' | 'paused'
    let isCountingDown = false;
    let countdownTimers = [];
    let countdownRAF = null;

    function applyDesktopScale() {
      const isCoarse = window.matchMedia('(pointer: coarse)').matches;
      const wide   = window.matchMedia('(min-width: 1024px)').matches;
      const wider  = window.matchMedia('(min-width: 1440px)').matches;
      let u = 1;
      if (!isCoarse && (wide || wider)) u = wider ? 1.8 : 1.5;
      uiScale = u;
      const stage = document.getElementById('stage');
      if (stage) {
        stage.style.setProperty('--u', String(u));
        stage.style.maxWidth = `${Math.round(420 * u)}px`;
      }
      updateHitbarPosition();
    }

    function getCanvasRect(){ return canvas.getBoundingClientRect(); }
    function getScaleY(){ return getCanvasRect().height / H; }
    function getJudgeLineYCss() {
      const rectH = getCanvasRect().height;
      return (currentDirection === 'up') ? (HITKEY_BASE * uiScale / 2) : (rectH - HITKEY_BASE * uiScale / 2);
    }
    function getJudgeLineYInternal() { return getJudgeLineYCss() / getScaleY(); }

    // 遊戲狀態
    const keys = ['d','f','j','k'];
    const keyToLane = { d:0, f:1, j:2, k:3 };
    const laneDirs = ['left','down','up','right'];

    let score = 0, combo = 0, lastJudgementText = '-';
    let startTime = 0, running = false, paused = false, loopId = null;
    let chart = [], comboFlash = '';
    let elapsedTimeBeforePause = 0;
    let nowT = 0, prevTs = 0;

    const hitSound = document.getElementById('hitSound');
    const bgm = document.getElementById('bgm');

    let baseNoteSpeed = 550;
    let noteSpeed = baseNoteSpeed;

    const FNF_WINDOWS = { sick: 70, good: 118, bad: 123, shit: 138 };
    const FNF_SCORES  = { sick: 350, good: 200, bad: 100, shit: -50, miss: -300, ghost: -150 };
    const MISS_Y_OFFSET = 40;
    const TOUCH_WINDOW_MS = FNF_WINDOWS.shit;
    const LATE_MISS_GRACE_MS = 120;

    // 統計
    let missCount = 0;
    let gameOver = false;
    let stats = { sick:0, good:0, bad:0, shit:0, miss:0 };

    // 當前資訊
    let currentSongTitle = '-';
    let currentDifficulty = 'normal';
    let currentDirection = 'down';
    let currentJudgeMode = 'old';

    // 音樂選擇（必選）
    let selectedSongFile = null;

    // 曲庫（請確保 /music 檔名一致）
    const SONGS = [
      "Charlie Puth - Light Switch [Official Music Video] - Charlie Puth.mp3",
      "Creepy Nuts - オトノケ(Otonoke) 【Official MV】 [Dandandan OP] - Creepy Nuts.mp3",
      "Creepy Nuts ”Mirage” × Anime ”Call of the Night” Collaboration Music Video Opening Theme Song - Creepy Nuts.mp3",
      "Creepy Nuts ”Nemure” × Anime ”Call of the Night” Collaboration Music Video Ending Theme Song - Creepy Nuts (1).mp3",
      "Creepy Nuts｢Bling-Bang-Bang-Born｣ × TV Anime｢マッシュル-MASHLE-｣ Collaboration Music Video #BBBBダンス - Creepy Nuts.mp3",
      "KANA-BOON - Silhouette - KANABOONVEVO.mp3",
      "Lost Sky - Fearless pt.II (feat. Chris Linton) Trap NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky - Vision pt. II (feat. She Is Jules) Future Trap NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky - Where We Started (feat. Jex) Melodic Dubstep NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky, Sara Skinner - Dreams pt. II (feat. Sara Skinner) [NCS Release].mp3",
      "OneRepublic - Nobody (from Kaiju No. 8) [Official Music Video] - OneRepublicVEVO.mp3",
      "YOASOBI「Watch me!」Official Music Video - Ayase _ YOASOBI.mp3",
      "yung kai - blue (official music video) - yung kai.mp3",
      "【AKASAKI】Bunny Girl _ バニーガール（Lyric Video） - AKASAKI (19).mp3",
      "【MV】隙_ゆーり【オリジナル】 - ゆーり🍎🐥〔24〕・yuri (1).mp3",
      "【imase】NIGHT DANCER（MV） - imase.mp3",
      "【オリジナル樂曲】粛聖!! ロリ神レクイエム☆ _ しぐれうい（9さい）【IOSYS（まろん&D.watt）】 - しぐれうい.mp3",
      "なとり - Overdose - なとり _ natori.mp3",
      "ロクデナシ「ただ聲一つ」_ Rokudenashi - One Voice【Official Music Video】 - ロクデナシ _ Rokudenashi.mp3",
      "好きだから。_ 『ユイカ』【MV】 - 『ユイカ』.mp3",
      "廻廻奇譚 - Eve MV - Eve.mp3",
      "青のすみか _ キタニタツヤ - Where Our Blue Is _ Tatsuya Kitani - キタニタツヤ _ Tatsuya Kitani.mp3"
    ];

    /* ====== 畫面切換 ====== */
    function showOnly(id) {
      const ids = ['menuScreen','musicScreen','optionsScreen','gameScreen','pauseScreen','endScreen'];
      ids.forEach(x => document.getElementById(x).style.display = (x===id ? 'block' : 'none'));
      if (id !== 'gameScreen') document.getElementById('gameScreen').classList.remove('blur');
    }
    function goToMenu() {
      cancelCountdown();              // <- 防止倒數殘留
      stopGameLoop();                 // <- 防止遊戲 RAF 殘留
      stopAndResetBgm();              // <- 立刻停歌
      showOnly('menuScreen');
      phase = 'menu';
      document.body.classList.remove('ex-mode');
      document.getElementById('menuChosenSong').textContent = selectedSongFile ? selectedSongFile.replace(/\.mp3$/i,'') : '尚未選擇';
    }
    function showOptions() { showOnly('optionsScreen'); }
    function showMusic() {
      const sel = document.getElementById('songSelect');
      if (!sel.dataset.filled) {
        sel.innerHTML = '';
        SONGS.forEach((f) => {
          const opt = document.createElement('option');
          opt.value = f;
          opt.textContent = f.replace(/\.mp3$/i,'');
          sel.appendChild(opt);
        });
        sel.addEventListener('change', () => {
          document.getElementById('chosenSongLabel').textContent = sel.value ? sel.options[sel.selectedIndex].textContent : '尚未選擇';
        });
        sel.dataset.filled = '1';
      }
      showOnly('musicScreen');
    }
    function confirmSong() {
      const sel = document.getElementById('songSelect');
      if (!sel.value) { alert('請先選擇音樂'); return; }
      selectedSongFile = sel.value;
      document.getElementById('chosenSongLabel').textContent = sel.options[sel.selectedIndex].textContent;
      document.getElementById('menuChosenSong').textContent = sel.options[sel.selectedIndex].textContent;
      goToMenu();
    }

    /* ====== HUD ====== */
    function updateHUD() {
      document.getElementById('score').textContent = score;
      document.getElementById('combo').textContent = combo;
      document.getElementById('judgement').textContent = lastJudgementText;
      document.getElementById('missCount').textContent = missCount;
      document.getElementById('songTitle').textContent = currentSongTitle;
      document.getElementById('diffLabel').textContent = currentDifficulty.toUpperCase();
      document.getElementById('dirLabel').textContent = (currentDirection === 'up' ? '上升' : '下落');
      document.getElementById('judgeLabel').textContent = (currentJudgeMode === 'old' ? 'Old' : 'New');
    }

    /* ====== 視覺（FNF 箭頭 + 現代感） ====== */
    const laneColors = ['#b266ff', '#66ccff', '#66ff66', '#ff6666'];
    const receptorPulse = [0,0,0,0];
    const hitFx = [];

    function colorLerp(a, b, t){
      const pa = parseInt(a.slice(1),16), pb = parseInt(b.slice(1),16);
      const ar=(pa>>16)&255, ag=(pa>>8)&255, ab=pa&255;
      const br=(pb>>16)&255, bg=(pb>>8)&255, bb=pb&255;
      const r=Math.round(ar+(br-ar)*t), g=Math.round(ag+(bg-ag)*t), b2=Math.round(ab+(bb-ab)*t);
      return `rgb(${r},${g},${b2})`;
    }
    function dirToAngle(dir){
      switch(dir){ case 'up': return 0; case 'down': return Math.PI; case 'left': return -Math.PI/2; case 'right': return Math.PI/2; }
      return 0;
    }
    function drawArrow(x, y, size, dir, baseColor, glow = 1, innerScale = 0.7){
      const angle = dirToAngle(dir);
      const Hh = size * 1.15, Wd = size, headH = Hh * 0.55;

      const drawShape = (scale=1, fillStyle=baseColor, strokeStyle='#000', shadow=0)=>{
        ctx.save(); ctx.translate(x, y); ctx.rotate(angle); ctx.scale(scale, scale);
        if (shadow>0){ ctx.shadowColor = baseColor; ctx.shadowBlur = shadow; }
        ctx.beginPath();
        ctx.moveTo(0, -Hh/2);
        ctx.lineTo(Wd/2, -Hh/2 + headH);
        ctx.lineTo(Wd*0.22, -Hh/2 + headH);
        ctx.lineTo(Wd*0.22,  Hh/2);
        ctx.lineTo(-Wd*0.22, Hh/2);
        ctx.lineTo(-Wd*0.22, -Hh/2 + headH);
        ctx.lineTo(-Wd/2, -Hh/2 + headH);
        ctx.closePath();
        const grad = ctx.createLinearGradient(0, -Hh/2, 0, Hh/2);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.25, colorLerp('#ffffff', baseColor, .2));
        grad.addColorStop(1, baseColor);
        ctx.fillStyle = (fillStyle === 'gradient') ? grad : fillStyle;
        ctx.fill();
        ctx.lineWidth = 6; ctx.strokeStyle = strokeStyle; ctx.stroke();
        ctx.restore();
      };
      drawShape(1.0, 'gradient', '#000000', 16*glow);
      drawShape(innerScale, 'gradient', colorLerp(baseColor,'#ffffff',0.25), 6*glow);
    }
    function drawRing(x,y,r,alpha){
      ctx.save(); ctx.globalAlpha = alpha;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
      ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 3; ctx.stroke();
      ctx.restore();
    }
    function flashKeyByLane(laneIdx) { receptorPulse[laneIdx] = 1; }

    /* ====== 判定 ====== */
    function judge(dtMs, lane) {
      const adt = Math.abs(dtMs);
      let rating = '', scoreDelta = 0;
      if (adt <= FNF_WINDOWS.sick)      { rating = 'SICK!'; scoreDelta = FNF_SCORES.sick; stats.sick++; combo++; }
      else if (adt <= FNF_WINDOWS.good) { rating = 'GOOD';  scoreDelta = FNF_SCORES.good; stats.good++; combo++; }
      else if (adt <= FNF_WINDOWS.bad)  { rating = 'BAD';   scoreDelta = FNF_SCORES.bad;  stats.bad++;  combo++; }
      else if (adt <= FNF_WINDOWS.shit) { rating = 'SHIT';  scoreDelta = FNF_SCORES.shit; stats.shit++; combo = Math.max(0, combo-1); }
      else { miss(); return; }
      score = Math.max(0, score + scoreDelta);
      lastJudgementText = rating;
      receptorPulse[lane] = 1;
      hitFx.push({lane, t0: nowT, life: 0.25});
      updateHUD();
      try{ hitSound.currentTime = 0; hitSound.play(); }catch{}
      if (combo > 0 && combo % 10 === 0) { comboFlash = `COMBO x${combo}!!`; setTimeout(() => comboFlash = '', 800); }
    }
    function miss() {
      lastJudgementText = 'MISS';
      combo = 0; missCount++; stats.miss++;
      score = Math.max(0, score + FNF_SCORES.miss);
      updateHUD();
      if (currentDifficulty === 'ex' && missCount > 15) triggerFailOnce('你輸了！EX 模式 MISS 超過 15 次');
    }
    function ghostTap(lane) { lastJudgementText='MISS'; combo=0; score=Math.max(0, score+FNF_SCORES.ghost); receptorPulse[lane]=0.5; updateHUD(); }
    function triggerFailOnce(msg) {
      if (gameOver) return; gameOver = true; running = false;
      stopGameLoop(); stopAndResetBgm();
      setTimeout(() => { alert(msg); goToMenu(); }, 0);
    }

    /* ====== 自動生譜（原版難度） ====== */
    function generateChart(durationSec) {
      chart = [];
      const difficulty = currentDifficulty;
      let doubleNoteChance = 0.35;
      let timeGapMin = 0.20;
      let timeGapMax = 0.45;
      if (difficulty === 'beginner')      { doubleNoteChance = 0.15; timeGapMin = 0.30; timeGapMax = 0.60; }
      else if (difficulty === 'easy')     { doubleNoteChance = 0.20; timeGapMin = 0.25; timeGapMax = 0.50; }
      else if (difficulty === 'normal')   { doubleNoteChance = 0.35; timeGapMin = 0.20; timeGapMax = 0.45; }
      else if (difficulty === 'hard')     { doubleNoteChance = 0.55; timeGapMin = 0.15; timeGapMax = 0.35; }

      if (!(difficulty === 'ex' || difficulty === 'hell')) {
        let time = 1;
        while (time < durationSec) {
          const lanesUsed = new Set();
          const notesThisFrame = [];
          const count = Math.random() < doubleNoteChance ? 2 : 1;
          while (notesThisFrame.length < count) {
            const lane = Math.floor(Math.random() * 4);
            if (!lanesUsed.has(lane)) {
              lanesUsed.add(lane);
              notesThisFrame.push({ t: time, lane, type: 'tap', hit: false, y: -50 });
            }
          }
          chart.push(...notesThisFrame);
          time += Math.random() * (timeGapMax - timeGapMin) + timeGapMin;
        }
        return;
      }

      // EX / HELL（原本的較密集邏輯）
      const beat = 0.5;
      let t = 1;
      let laneCursor = 0;
      const nextLane = () => { laneCursor = (laneCursor + 1) % 4; return laneCursor; };
      const pushNote = (tt, lane) => chart.push({ t: tt, lane, type: 'tap', hit: false, y: -50 });
      const randLane = () => Math.floor(Math.random() * 4);

      while (t < durationSec) {
        if (difficulty === 'ex') {
          pushNote(t, nextLane());
          if (Math.random() < 0.60) pushNote(t, (laneCursor + 2) % 4);
          if (Math.random() < 0.35) pushNote(t + beat / 2, (laneCursor + 1) % 4);
          if (Math.random() < 0.18) {
            pushNote(t + beat / 3, randLane());
            pushNote(t + 2 * beat / 3, randLane());
          }
          t += Math.random() < 0.5 ? beat / 2 : beat;
        } else {
          pushNote(t, nextLane());
          if (Math.random() < 0.85) pushNote(t, (laneCursor + 2) % 4);
          pushNote(t + beat / 2, (laneCursor + 1) % 4);
          if (Math.random() < 0.4) {
            pushNote(t + beat / 4, randLane());
            pushNote(t + 3 * beat / 4, randLane());
          }
          t += beat / 2;
        }
      }
    }

    /* ====== 幾何 & 命中判定 ====== */
    function noteYAtTimeFor(tHit, tNow) {
      const judge = getJudgeLineYInternal();
      if (currentDirection === 'down') return judge - (tHit - tNow) * noteSpeed;
      return judge + (tHit - tNow) * noteSpeed;
    }
    function isTapMiss(n, currentTimeSec) {
      const judge = getJudgeLineYInternal();
      const dtMs = (currentTimeSec - n.t) * 1000;
      const beyondDown = n.y > judge + MISS_Y_OFFSET;
      const beyondUp = n.y < judge - MISS_Y_OFFSET;
      const graceOver = dtMs > LATE_MISS_GRACE_MS;
      return (currentDirection === 'down') ? (beyondDown && graceOver) : (beyondUp && graceOver);
    }

    /* ====== 更新 & 繪圖 ====== */
    function updateHitbarPosition() {
      if (!hitbar || document.getElementById('gameScreen').style.display === 'none') return;
      const topPx = getJudgeLineYCss() - (HITKEY_BASE * uiScale / 2);
      hitbar.style.top = `${topPx}px`;
    }

    function update(t, dt) {
      chart.forEach(n => { n.y = noteYAtTimeFor(n.t, t); });
      chart.forEach(n => { if (!n.hit && isTapMiss(n, t)) { n.hit = true; miss(); } });
      for (let i=0;i<4;i++) receptorPulse[i] = Math.max(0, receptorPulse[i] - dt*3.2);
      for (let i = hitFx.length-1; i>=0; i--) if (t - hitFx[i].t0 > hitFx[i].life) hitFx.splice(i,1);
    }

    function render({skipNotes=false} = {}) {
      const judge = getJudgeLineYInternal();
      ctx.clearRect(0, 0, W, H);

      // receptor（倒數也畫）
      for (let lane=0; lane<4; lane++){
        const x = lane * laneWidth + laneWidth / 2;
        const pulse = receptorPulse[lane];
        const glowScale = 1 + 0.18 * pulse;
        drawArrow(x, judge, NOTE_BASE * glowScale, laneDirs[lane], laneColors[lane], 0.8 + pulse);
      }

      // 音符（倒數時不畫，避免誤解正在開始）
      if (!skipNotes) {
        chart.forEach(n => {
          if (n.hit) return;
          const x = n.lane * laneWidth + laneWidth / 2;
          drawArrow(x, n.y, NOTE_BASE, laneDirs[n.lane], laneColors[n.lane], 0.6);
        });
      }

      hitFx.forEach(fx=>{
        const x = fx.lane * laneWidth + laneWidth / 2;
        const p = Math.min(1, (nowT - fx.t0) / fx.life);
        drawRing(x, judge, 18 + 80*p, 1 - p);
      });

      if (lastJudgementText !== '-') {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        const offset = (currentDirection === 'up') ? 120 : -40;
        ctx.fillText(lastJudgementText, W / 2, judge + offset);
      }

      if (comboFlash) {
        ctx.fillStyle = '#ff78b5';
        ctx.font = 'bold 36px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(comboFlash, W / 2, H / 2 - 100);
      }
    }

    function loop(ts) {
      if (paused) return;
      if (!prevTs) prevTs = ts;
      nowT = (ts - startTime) / 1000;
      const dt = Math.max(0, (ts - prevTs) / 1000);
      prevTs = ts;

      update(nowT, dt);
      render();

      if (chart.every(n => n.hit)) {
        running = false;
        lastJudgementText = 'END';
        updateHUD();
        document.getElementById('finalSong').textContent = currentSongTitle;
        document.getElementById('finalDiff').textContent = currentDifficulty.toUpperCase();
        document.getElementById('finalDir').textContent  = (currentDirection === 'up' ? '上升' : '下落');
        document.getElementById('finalJudge').textContent= (currentJudgeMode === 'old' ? 'Old' : 'New');
        document.getElementById('finalScore').textContent = score;
        document.getElementById('statSick').textContent = stats.sick;
        document.getElementById('statGood').textContent = stats.good;
        document.getElementById('statBad').textContent = stats.bad;
        document.getElementById('statShit').textContent = stats.shit;
        document.getElementById('statMiss').textContent = stats.miss;

        showOnly('endScreen');
        phase = 'menu';
        return;
      }

      loopId = requestAnimationFrame(loop);
    }
    function stopGameLoop(){ try{ cancelAnimationFrame(loopId); }catch{} loopId=null; prevTs=0; }

    /* ====== 倒數處理（可中止） ====== */
    function showCountdown(startCallback) {
      cancelCountdown();                 // 確保乾淨
      isCountingDown = true;
      phase = 'countdown';

      // 倒數時先顯示 receptor（不畫音符）
      const countdownLoop = () => {
        if (!isCountingDown) return;
        render({skipNotes:true});
        countdownRAF = requestAnimationFrame(countdownLoop);
      };
      countdownLoop();

      const el = document.getElementById('countdownText');
      el.style.display = 'block';
      const steps = ['Ready', '3', '2', '1', 'Go!'];
      const stepDur = 700;

      const playStep = (i) => {
        if (!isCountingDown) return;
        el.textContent = steps[i];
        // 無閃爍：只做縮放動畫
        el.style.animation = 'none';
        // 觸發一次重排以重啟動畫
        void el.offsetWidth;
        el.style.animation = 'popScale .55s ease-out';
      };

      // 逐步排程
      for (let i=0;i<steps.length;i++){
        countdownTimers.push(setTimeout(()=>playStep(i), i*stepDur));
      }
      // 結束後啟動遊戲
      countdownTimers.push(setTimeout(()=>{
        if (!isCountingDown) return;
        el.style.display = 'none';
        isCountingDown = false;
        cancelAnimationFrame(countdownRAF);
        startCallback();                 // 真正開始
      }, steps.length*stepDur));
    }

    function cancelCountdown() {
      if (!isCountingDown && countdownTimers.length===0 && !countdownRAF) return;
      isCountingDown = false;
      countdownTimers.forEach(id=>clearTimeout(id));
      countdownTimers = [];
      try{ cancelAnimationFrame(countdownRAF); }catch{}
      countdownRAF = null;
      const el = document.getElementById('countdownText');
      el.style.animation = 'none';
      el.style.display = 'none';
    }

    function stopAndResetBgm(){
      try { bgm.pause(); } catch {}
      try { bgm.currentTime = 0; } catch {}
    }

    /* ====== 輸入（鍵盤＋觸控） ====== */
    window.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();

      if (k in keyToLane) {
        // 倒數時禁止打鍵（僅展示 receptor）
        if (phase === 'playing') onLanePress(keyToLane[k]);
        e.preventDefault();
        return;
      }

      if (e.key === 'Escape') {
        if (phase === 'countdown') {        // << 修復：倒數中 ESC 直接回主選單且停歌
          cancelCountdown();
          goToMenu();
          return;
        }
        if (phase === 'playing') { paused ? resumeGame() : pauseGame(); return; }
        if (phase === 'paused')  { resumeGame(); return; }
      }
    });

    canvas.addEventListener('pointerdown', (e) => {
      if (phase !== 'playing') return;      // 倒數時不處理點擊
      e.preventDefault();
      const rect = getCanvasRect();
      const x = e.clientX - rect.left;
      const cssLaneWidth = rect.width / 4;
      const lane = Math.min(3, Math.max(0, Math.floor(x / cssLaneWidth)));
      onLanePress(lane);
    }, { passive:false });

    function onLanePress(lane) {
      if (!running) return;
      const tNow = (performance.now() - startTime) / 1000;

      let bestIdx = -1, bestAbs = Infinity;
      for (let i = 0; i < chart.length; i++) {
        const n = chart[i];
        if (n.hit || n.lane !== lane) continue;
        const dtMs = (tNow - n.t) * 1000;
        const adt = Math.abs(dtMs);
        if (adt <= TOUCH_WINDOW_MS && adt < bestAbs) { bestAbs = adt; bestIdx = i; }
      }

      if (bestIdx >= 0) {
        const n = chart[bestIdx];
        judge((tNow - n.t) * 1000, lane);
        n.hit = true;
        flashKeyByLane(lane);
      } else {
        if (currentJudgeMode === 'old') ghostTap(lane);
        flashKeyByLane(lane);
      }
    }

    /* ====== 流程 ====== */
    function startGame() {
      if (!selectedSongFile) { alert('請先選擇音樂'); showMusic(); return; }

      const difficulty = document.getElementById('difficultySelect').value;
      const speedMultiplierSelect = document.getElementById('speedMultiplier');
      const dir = document.getElementById('noteDirection').value;
      const jmode = document.getElementById('judgeMode').value;
      currentDifficulty = difficulty;
      currentDirection  = dir;
      currentJudgeMode  = jmode;

      let multiplier = parseFloat(speedMultiplierSelect.value);
      if      (difficulty === 'beginner') multiplier = 0.8;
      else if (difficulty === 'easy')     multiplier = 0.9;
      else if (difficulty === 'ex')       multiplier = 1.8;
      noteSpeed = baseNoteSpeed * multiplier;

      document.body.classList.toggle('ex-mode', difficulty === 'ex');

      // 重置狀態
      stopGameLoop();
      score = 0; combo = 0; lastJudgementText = '-'; comboFlash = '';
      chart = []; paused = false; running = true; missCount = 0; gameOver = false;
      stats = { sick:0, good:0, bad:0, shit:0, miss:0 };
      elapsedTimeBeforePause = 0; nowT = 0; prevTs = 0;
      for (let i=0;i<4;i++) receptorPulse[i]=0;
      hitFx.length = 0;
      updateHUD();

      currentSongTitle = selectedSongFile.replace(/\.mp3$/i, '');
      const url = 'music/' + encodeURIComponent(selectedSongFile);
      bgm.src = url; bgm.load();

      showOnly('gameScreen');
      phase = 'countdown';

      applyDesktopScale();
      requestAnimationFrame(updateHitbarPosition);
      setTimeout(updateHitbarPosition, 0);
      setTimeout(updateHitbarPosition, 50);

      updateHUD();

      let chartFinalized = false;
      generateChart(120);
      bgm.onloadedmetadata = () => {
        if (chartFinalized) return;
        const durationSec = (!isNaN(bgm.duration) && bgm.duration > 0) ? bgm.duration : 120;
        generateChart(durationSec);
        chartFinalized = true;
      };

      // 倒數（顯示 receptor、不顯示音符；可中止）
      showCountdown(() => {
        if (phase !== 'countdown') return;  // 若被中止就不啟動
        phase = 'playing';
        startTime = performance.now();
        try { bgm.currentTime = 0; bgm.play().catch(()=>{}); } catch {}
        loopId = requestAnimationFrame(loop);
      });
    }

    function pauseGame() {
      if (phase === 'countdown') {
        // 倒數時按暫停鍵：直接視為取消回主選單
        cancelCountdown();
        goToMenu();
        return;
      }
      if (!running || paused) return;
      paused = true;
      phase = 'paused';
      try { bgm.pause(); } catch {}
      stopGameLoop();
      elapsedTimeBeforePause = (performance.now() - startTime) / 1000;
      document.getElementById('gameScreen').classList.add('blur');
      showOnly('pauseScreen');
    }

    function resumeGame() {
      if (!paused) return;
      paused = false;
      phase = 'playing';
      showOnly('gameScreen');
      document.getElementById('gameScreen').classList.remove('blur');

      applyDesktopScale();
      requestAnimationFrame(updateHitbarPosition);

      startTime = performance.now() - (elapsedTimeBeforePause * 1000);
      try { bgm.play().catch(()=>{}); } catch {}
      loopId = requestAnimationFrame(loop);
    }

    /* ====== 初始化 ====== */
    function renderIdle() {
      // 在主選單/選項/音樂頁也能維持舞台比例運算
      if (document.getElementById('gameScreen').style.display === 'block') return;
      updateHitbarPosition();
    }

    applyDesktopScale();
    window.addEventListener('resize', () => { applyDesktopScale(); renderIdle(); }, { passive: true });
    window.addEventListener('scroll', updateHitbarPosition, { passive: true });
    if (window.visualViewport) {
      ['resize','scroll'].forEach(ev => {
        window.visualViewport.addEventListener(ev, () => { applyDesktopScale(); }, { passive: true });
      });
    }

    // 禁右鍵 / 禁縮放
    document.addEventListener("contextmenu", e => e.preventDefault());
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('dblclick', e => e.preventDefault());

    goToMenu();
  </script>
</body>
</html>











