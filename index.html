<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <!-- 行動裝置：關閉縮放、雙擊放大、pinch -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>DFJK 節奏遊戲</title>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
  <style>
    html, body { touch-action: manipulation; }
    body {
      margin: 0; background: #0f1220; color: #fff; font-family: sans-serif;
      text-align: center; transition: background 0.5s ease;
    }
    body.ex-mode { background: linear-gradient(to bottom, #ff3300, #990000, #000000); }

    /* 舞台容器（手機 1.0，桌機用 --u 放大） */
    #stage {
      position: relative;
      width: 95%;
      max-width: 420px;
      margin: 20px auto;
      --u: 1;
    }

    canvas {
      display: block;
      background: #1f2340;
      border: 2px solid #fff;
      width: 100%;
      height: auto;
      touch-action: manipulation;
    }

    /* DOM hitbar 只是定位參考（FNF receptor 改由 canvas 畫） */
    .hitbar {
      position: absolute; left: 0; width: 100%;
      display: flex; justify-content: space-between; align-items: center;
      height: calc(90px * var(--u));
      z-index: 2;
      opacity: 0;
      pointer-events: none;
    }
    .hitkey { flex:1; margin:0 5px; height:calc(90px * var(--u)); }

    .hud { font-size: 18px; margin-top: 10px; line-height: 1.6; }
    .songline { font-size: 14px; opacity: .9; }
    button {
      margin:10px; padding:10px 20px; font-size:18px; background:#78d5ff; border:none; border-radius:8px; cursor:pointer;
    }
    #menuScreen, #musicScreen, #endScreen, #optionsScreen, #pauseScreen { padding-top: 120px; }
    .blur { filter: blur(6px); pointer-events: none; user-select: none; }
    #pauseButton { position: absolute; top: 10px; right: 10px; z-index: 3; }
    /* 手機 + 上升打擊時把暫停鍵移到底部避免蓋到右側 lane */
    .pause-bottom { top: auto !important; bottom: 10px !important; }

    /* 倒數文字：純縮放脈衝 */
    #countdownText {
      position: absolute; top: 40%; left: 50%; transform: translate(-50%,-50%);
      font-family: 'Fredoka One', sans-serif; font-size: 72px; color: #fff; text-shadow: 2px 2px 8px #000; z-index: 5;
      pointer-events: none; opacity: 1; will-change: transform;
    }
    @keyframes popScale {
      0% { transform: translate(-50%,-50%) scale(0.85); }
      50% { transform: translate(-50%,-50%) scale(1.12); }
      100% { transform: translate(-50%,-50%) scale(1.00); }
    }

    .row { margin: 10px 0; }
    label { margin-right: 6px; }
    select { padding: 6px 10px; border-radius: 6px; border: 1px solid #445; background:#12152a; color:#fff; }

    /* 音樂選單 */
    #songSelect { width: 90%; max-width: 420px; height: 280px; }
    #musicScreen .hint { opacity: .8; font-size: 14px; margin-top: 6px; }

    /* 音樂播放警示 */
    #audioWarn{
      position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
      background:#ff4d4f; color:#fff; padding:8px 12px; border-radius:8px;
      z-index: 9999; box-shadow: 0 2px 6px rgba(0,0,0,.3); display:none; font-weight:600;
    }
    #audioWarn button{ margin-left:8px; border:none; border-radius:6px; padding:6px 10px; cursor:pointer; }
  </style>
</head>
<body>
  <!-- 主選單 -->
  <div id="menuScreen">
    <h1>🎵 DFJK 節奏遊戲</h1>
    <div class="row">
      <button onclick="startGame()">開始遊戲</button>
      <button onclick="showMusic()">音樂</button>
      <button onclick="showOptions()">選項</button>
    </div>
    <div class="row">
      已選曲目：<span id="menuChosenSong">尚未選擇</span>
    </div>
  </div>

  <!-- 音樂選單（必選） -->
  <div id="musicScreen" style="display:none;">
    <h2>🎼 選擇本局曲目</h2>
    <div class="row">
      <select id="songSelect" size="12"></select>
      <div class="hint">必須選擇曲目才可開始。</div>
    </div>
    <div class="row">
      <button onclick="confirmSong()">確定</button>
      <button onclick="goToMenu()">回主選單</button>
    </div>
    <div class="row">
      已選：<span id="chosenSongLabel">尚未選擇</span>
    </div>
  </div>

  <!-- 選項 -->
  <div id="optionsScreen" style="display:none;">
    <h2>⚙️ 遊戲選項</h2>

    <div class="row">
      <label for="difficultySelect">難度：</label>
      <select id="difficultySelect">
        <option value="ex">EX（極限）</option>
        <option value="hell">地獄</option>
        <option value="hard">困難</option>
        <option value="normal" selected>普通</option>
        <option value="easy">簡單</option>
        <option value="beginner">初學者</option>
      </select>
    </div>

    <div class="row">
      <label for="speedMultiplier">速度倍率：</label>
      <select id="speedMultiplier">
        <option value="1">1.0x（標準）</option>
        <option value="1.1">1.1x</option>
        <option value="1.2">1.2x</option>
        <option value="1.3">1.3x</option>
        <option value="1.6">1.6x</option>
        <option value="2.0">2.0x</option>
      </select>
    </div>

    <div class="row">
      <label for="noteDirection">音符方向：</label>
      <select id="noteDirection">
        <option value="down" selected>下落打擊（打擊線在底）</option>
        <option value="up">上升打擊（打擊線在頂）</option>
      </select>
    </div>

    <div class="row">
      <label for="judgeMode">判定模式：</label>
      <select id="judgeMode">
        <option value="old" selected>Old Input（含 Ghost 懲罰）</option>
        <option value="new">New Input（移除 WRONG）</option>
      </select>
    </div>

    <!-- 新增：音量調節 -->
    <div class="row">
      <label for="volumeSlider">音量：</label>
      <input type="range" id="volumeSlider" min="0" max="1" step="0.01">
      <span id="volumeValue">80%</span>
    </div>

    <div class="row">
      <button onclick="goToMenu()">回主選單</button>
    </div>
  </div>

  <!-- 遊戲畫面 -->
  <div id="gameScreen" style="display:none; position:relative;">
    <button id="pauseButton" onclick="pauseGame()">⏸️</button>

    <div id="stage">
      <canvas id="gameCanvas" width="420" height="640"></canvas>

      <div class="hitbar">
        <div class="hitkey" id="key-d"></div>
        <div class="hitkey" id="key-f"></div>
        <div class="hitkey" id="key-j"></div>
        <div class="hitkey" id="key-k"></div>
      </div>
    </div>

    <div class="hud">
      分數：<span id="score">0</span>　
      連擊：<span id="combo">0</span>　
      判定：<span id="judgement">-</span>　
      MISS：<span id="missCount">0</span>
      <div class="songline">
        曲目：<span id="songTitle">-</span>　｜　難度：<span id="diffLabel">-</span>　｜　方向：<span id="dirLabel">-</span>　｜　判定：<span id="judgeLabel">-</span>
      </div>
    </div>
  </div>

  <!-- 暫停 -->
  <div id="pauseScreen" style="display:none;">
    <h2>⏸️ 遊戲暫停</h2>
    <button onclick="resumeGame()">▶️ 繼續</button>
    <button onclick="goToMenu()">回主選單</button>
  </div>

  <!-- 結算 -->
  <div id="endScreen" style="display:none;">
    <h2>🎮 遊戲結束！</h2>
    <p>曲目：<span id="finalSong">-</span></p>
    <p>難度：<span id="finalDiff">-</span></p>
    <p>方向：<span id="finalDir">-</span></p>
    <p>判定：<span id="finalJudge">-</span></p>
    <p>分數：<span id="finalScore">0</span></p>
    <p>SICK：<span id="statSick">0</span></p>
    <p>GOOD：<span id="statGood">0</span></p>
    <p>BAD：<span id="statBad">0</span></p>
    <p>SHIT：<span id="statShit">0</span></p>
    <p>MISS：<span id="statMiss">0</span></p>
    <button onclick="startGame()">再玩一次</button>
    <button onclick="goToMenu()">回主選單</button>
  </div>

  <!-- 音樂播放警示（自動播放被擋、找不到檔案、載入卡住） -->
  <div id="audioWarn">
    <span id="audioWarnText">音樂播放異常</span>
    <button id="audioRetryBtn" onclick="retryBgm()">重試播放</button>
  </div>

  <div id="countdownText" style="display:none;"></div>

  <audio id="hitSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_6e3e3b6f3f.mp3?filename=click-124467.mp3"></audio>
  <audio id="bgm"></audio>

  <script>
    /* ========= 參數 ========= */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

    // 內部遊戲座標（固定 420x640）
    const W = canvas.width, H = canvas.height;
    const laneWidth = W / 4;
    const hitbar = document.querySelector('.hitbar');

    // —— UI 縮放（桌機放大、手機不動） —— //
    const HITKEY_BASE = 90;    // hitbar 高度（基準）
    const NOTE_BASE   = 60;    // 箭頭基準邊
    let uiScale = 1;

    // 狀態機
    let phase = 'menu'; // 'menu' | 'countdown' | 'playing' | 'paused'
    let isCountingDown = false;
    let countdownTimers = [];
    let countdownRAF = null;

    // ====== 手機穩定 60fps（只節流「渲染」，判定仍用真實時間） ======
    const IS_MOBILE = window.matchMedia('(pointer: coarse)').matches;
    let __fpsMode = IS_MOBILE ? 'stable60' : 'unlocked';
    let __lastRenderTs = 0;
    const __TARGET_INTERVAL = 1000 / 60;

    function applyDesktopScale() {
      const isCoarse = window.matchMedia('(pointer: coarse)').matches;
      const wide   = window.matchMedia('(min-width: 1024px)').matches;
      const wider  = window.matchMedia('(min-width: 1440px)').matches;
      let u = 1;
      if (!isCoarse && (wide || wider)) u = wider ? 1.8 : 1.5;
      uiScale = u;
      const stage = document.getElementById('stage');
      if (stage) {
        stage.style.setProperty('--u', String(u));
        stage.style.maxWidth = `${Math.round(420 * u)}px`;
      }
      recomputeLayout();
    }

    // ====== 版面快取（避免每幀 reflow） ======
    let cachedRectHeight = canvas.getBoundingClientRect().height;
    let cachedScaleY = cachedRectHeight / H;
    let cachedJudgeLineCss = (HITKEY_BASE * uiScale / 2);
    let cachedJudgeLineInternal = cachedJudgeLineCss / cachedScaleY;

    // === 遊戲中凍結版面（避免位移） ===
    let __layoutFrozen = false;
    let __frozenRectHeight = null, __frozenScaleY = null, __frozenJudgeCss = null;

    function freezeLayout() {
      const rect = canvas.getBoundingClientRect();
      __frozenRectHeight = rect.height;
      __frozenScaleY = __frozenRectHeight / H;
      __frozenJudgeCss = (currentDirection === 'up')
        ? (HITKEY_BASE * uiScale / 2)
        : (__frozenRectHeight - HITKEY_BASE * uiScale / 2);
      __layoutFrozen = true;
      updateHitbarPosition();
    }

    function unfreezeLayout() {
      __layoutFrozen = false;
      recomputeLayout();
    }

    function recomputeLayout() {
      if (__layoutFrozen) return;
      const rect = canvas.getBoundingClientRect();
      cachedRectHeight = rect.height;
      cachedScaleY = cachedRectHeight / H;
      cachedJudgeLineCss = (currentDirection === 'up') ? (HITKEY_BASE * uiScale / 2) : (cachedRectHeight - HITKEY_BASE * uiScale / 2);
      cachedJudgeLineInternal = cachedJudgeLineCss / cachedScaleY;
      updateHitbarPosition();
      positionPauseButton();
    }

    function getCanvasRect(){ return { height: __layoutFrozen ? __frozenRectHeight : cachedRectHeight }; }
    function getScaleY(){ return __layoutFrozen ? __frozenScaleY : cachedScaleY; }
    function getJudgeLineYCss(){ return __layoutFrozen ? __frozenJudgeCss : cachedJudgeLineCss; }
    function getJudgeLineYInternal(){ return getJudgeLineYCss() / getScaleY(); }

    // 遊戲狀態
    const keys = ['d','f','j','k'];
    const keyToLane = { d:0, f:1, j:2, k:3 };
    const laneDirs = ['left','down','up','right'];

    let score = 0, combo = 0, lastJudgementText = '-';
    let startTime = 0, running = false, paused = false, loopId = null;
    let chart = [], comboFlash = '';
    let elapsedTimeBeforePause = 0;
    let nowT = 0, prevTs = 0;

    const hitSound = document.getElementById('hitSound');
    const bgm = document.getElementById('bgm');

    let baseNoteSpeed = 550;
    let noteSpeed = baseNoteSpeed;

    const FNF_WINDOWS = { sick: 70, good: 118, bad: 123, shit: 138 };
    const FNF_SCORES  = { sick: 350, good: 200, bad: 100, shit: -50, miss: -300, ghost: -150 };
    const MISS_Y_OFFSET = 40;
    const TOUCH_WINDOW_MS = FNF_WINDOWS.shit;
    const LATE_MISS_GRACE_MS = 120;

    // 統計
    let missCount = 0;
    let gameOver = false;
    let stats = { sick:0, good:0, bad:0, shit:0, miss:0 };

    // 當前資訊
    let currentSongTitle = '-';
    let currentDifficulty = 'normal';
    let currentDirection = 'down';
    let currentJudgeMode = 'old';

    // 音樂選擇（必選）
    let selectedSongFile = null;

    // 曲庫（請確保 /music 檔名一致）
    const SONGS = [
      "Charlie Puth - Light Switch [Official Music Video] - Charlie Puth.mp3",
      "Creepy Nuts - オトノケ(Otonoke) 【Official MV】 [Dandandan OP] - Creepy Nuts.mp3",
      "Creepy Nuts ”Mirage” × Anime ”Call of the Night” Collaboration Music Video Opening Theme Song - Creepy Nuts.mp3",
      "Creepy Nuts ”Nemure” × Anime ”Call of the Night” Collaboration Music Video Ending Theme Song - Creepy Nuts (1).mp3",
      "Creepy Nuts｢Bling-Bang-Bang-Born｣ × TV Anime｢マッシュル-MASHLE-｣ Collaboration Music Video #BBBBダンス - Creepy Nuts.mp3",
      "KANA-BOON - Silhouette - KANABOONVEVO.mp3",
      "Lost Sky - Fearless pt.II (feat. Chris Linton) Trap NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky - Vision pt. II (feat. She Is Jules) Future Trap NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky - Where We Started (feat. Jex) Melodic Dubstep NCS - Copyright Free Music - NoCopyrightSounds.mp3",
      "Lost Sky, Sara Skinner - Dreams pt. II (feat. Sara Skinner) [NCS Release].mp3",
      "OneRepublic - Nobody (from Kaiju No. 8) [Official Music Video] - OneRepublicVEVO.mp3",
      "YOASOBI「Watch me!」Official Music Video - Ayase _ YOASOBI.mp3",
      "yung kai - blue (official music video) - yung kai.mp3",
      "【AKASAKI】Bunny Girl _ バニーガール（Lyric Video） - AKASAKI (19).mp3",
      "【MV】隙_ゆーり【オリジナル】 - ゆーり🍎🐥〔24〕・yuri (1).mp3",
      "【imase】NIGHT DANCER（MV） - imase.mp3",
      "【オリジナル樂曲】粛聖!! ロリ神レクイエム☆ _ しぐれうい（9さい）【IOSYS（まろん&D.watt）】 - しぐれうい.mp3",
      "なとり - Overdose - なとり _ natori.mp3",
      "ロクデナシ「ただ聲一つ」_ Rokudenashi - One Voice【Official Music Video】 - ロクデナシ _ Rokudenashi.mp3",
      "好きだから。_ 『ユイカ』【MV】 - 『ユイカ』.mp3",
      "廻廻奇譚 - Eve MV - Eve.mp3",
      "Toge Toge Sadistic - Enormita (youtube).mp3",
      "My dream girls - NACHERRY (youtube).mp3",
      "青のすみか _ キタニタツヤ - Where Our Blue Is _ Tatsuya Kitani - キタニタツヤ _ Tatsuya Kitani.mp3"
    ];

    /* ====== 畫面切換 ====== */
    function showOnly(id) {
      const ids = ['menuScreen','musicScreen','optionsScreen','gameScreen','pauseScreen','endScreen'];
      ids.forEach(x => document.getElementById(x).style.display = (x===id ? 'block' : 'none'));
      if (id !== 'gameScreen') document.getElementById('gameScreen').classList.remove('blur');
    }
    function goToMenu() {
      cancelCountdown();
      stopGameLoop();
      stopAndResetBgm();
      unfreezeLayout();  // 回選單解除凍結
      showOnly('menuScreen');
      phase = 'menu';
      document.body.classList.remove('ex-mode');
      document.getElementById('menuChosenSong').textContent = selectedSongFile ? selectedSongFile.replace(/\.mp3$/i,'') : '尚未選擇';
    }
    function showOptions() { showOnly('optionsScreen'); }
    function showMusic() { showOnly('musicScreen'); }

    // 進站就把曲目清單填好
    function fillSongList() {
      const sel = document.getElementById('songSelect');
      if (sel.dataset.filled) return;
      sel.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = '— 請選擇曲目 —';
      placeholder.disabled = true;
      placeholder.selected = !selectedSongFile;
      sel.appendChild(placeholder);
      SONGS.forEach((f) => {
        const opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f.replace(/\.mp3$/i,'');
        if (selectedSongFile === f) opt.selected = true;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', () => {
        document.getElementById('chosenSongLabel').textContent = sel.value ? sel.options[sel.selectedIndex].textContent : '尚未選擇';
      });
      sel.dataset.filled = '1';
    }

    function confirmSong() {
      const sel = document.getElementById('songSelect');
      if (!sel.value) { alert('請先選擇音樂'); return; }
      selectedSongFile = sel.value;
      document.getElementById('chosenSongLabel').textContent = sel.options[sel.selectedIndex].textContent;
      document.getElementById('menuChosenSong').textContent = sel.options[sel.selectedIndex].textContent;
      goToMenu();
    }

    /* ====== HUD ====== */
    function updateHUD() {
      document.getElementById('score').textContent = score;
      document.getElementById('combo').textContent = combo;
      document.getElementById('judgement').textContent = lastJudgementText;
      document.getElementById('missCount').textContent = missCount;
      document.getElementById('songTitle').textContent = currentSongTitle;
      document.getElementById('diffLabel').textContent = currentDifficulty.toUpperCase();
      document.getElementById('dirLabel').textContent = (currentDirection === 'up' ? '上升' : '下落');
      document.getElementById('judgeLabel').textContent = (currentJudgeMode === 'old' ? 'Old' : 'New');
    }

    /* ====== 視覺（現代風箭頭 & 效果） ====== */
    const laneColors = ['#b266ff', '#66ccff', '#66ff66', '#ff6666'];
    const receptorPulse = [0,0,0,0];
    const hitFx = [];

    function colorLerp(a, b, t){
      const pa = parseInt(a.slice(1),16), pb = parseInt(b.slice(1),16);
      const ar=(pa>>16)&255, ag=(pa>>8)&255, ab=pa&255;
      const br=(pb>>16)&255, bg=(pb>>8)&255, bb=pb&255;
      const r=Math.round(ar+(br-ar)*t), g=Math.round(ag+(bg-ag)*t), b2=Math.round(ab+(bb-ab)*t);
      return `rgb(${r},${g},${b2})`;
    }
    function dirToAngle(dir){
      switch(dir){ case 'up': return 0; case 'down': return Math.PI; case 'left': return -Math.PI/2; case 'right': return Math.PI/2; }
      return 0;
    }
    function drawArrow(x, y, size, dir, baseColor, glow = 1, innerScale = 0.7){
      const angle = dirToAngle(dir);
      const Hh = size * 1.15, Wd = size, headH = Hh * 0.55;

      const drawShape = (scale=1, fillStyle=baseColor, strokeStyle='#000', shadow=0)=>{
        ctx.save(); ctx.translate(x, y); ctx.rotate(angle); ctx.scale(scale, scale);
        if (shadow>0){ ctx.shadowColor = baseColor; ctx.shadowBlur = shadow; }
        ctx.beginPath();
        ctx.moveTo(0, -Hh/2);
        ctx.lineTo(Wd/2, -Hh/2 + headH);
        ctx.lineTo(Wd*0.22, -Hh/2 + headH);
        ctx.lineTo(Wd*0.22,  Hh/2);
        ctx.lineTo(-Wd*0.22, Hh/2);
        ctx.lineTo(-Wd*0.22, -Hh/2 + headH);
        ctx.lineTo(-Wd/2, -Hh/2 + headH);
        ctx.closePath();
        const grad = ctx.createLinearGradient(0, -Hh/2, 0, Hh/2);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.25, colorLerp('#ffffff', baseColor, .2));
        grad.addColorStop(1, baseColor);
        ctx.fillStyle = (fillStyle === 'gradient') ? grad : fillStyle;
        ctx.fill();
        ctx.lineWidth = 6; ctx.strokeStyle = strokeStyle; ctx.stroke();
        ctx.restore();
      };
      drawShape(1.0, 'gradient', '#000000', 16*glow);
      drawShape(innerScale, 'gradient', colorLerp(baseColor,'#ffffff',0.25), 6*glow);
    }
    function drawRing(x,y,r,alpha){
      if (__useLowQuality) return;
      ctx.save(); ctx.globalAlpha = alpha;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
      ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 3; ctx.stroke();
      ctx.restore();
    }
    function flashKeyByLane(laneIdx) { receptorPulse[laneIdx] = 1; }

    /* === Sprite: 預渲染箭頭/接收器，並修正 DPR 對齊 === */
    function drawArrowTo(ct, x, y, size, dir, baseColor, glow = 1, innerScale = 0.7){
      const angle = dirToAngle(dir);
      const Hh = size * 1.15, Wd = size, headH = Hh * 0.55;
      const drawShape = (scale=1, fillStyle=baseColor, strokeStyle='#000', shadow=0)=>{
        ct.save(); ct.translate(x, y); ct.rotate(angle); ct.scale(scale, scale);
        if (shadow>0){ ct.shadowColor = baseColor; ct.shadowBlur = shadow; }
        ct.beginPath();
        ct.moveTo(0, -Hh/2);
        ct.lineTo(Wd/2, -Hh/2 + headH);
        ct.lineTo(Wd*0.22, -Hh/2 + headH);
        ct.lineTo(Wd*0.22,  Hh/2);
        ct.lineTo(-Wd*0.22, Hh/2);
        ct.lineTo(-Wd*0.22, -Hh/2 + headH);
        ct.lineTo(-Wd/2, -Hh/2 + headH);
        ct.closePath();
        const grad = ct.createLinearGradient(0, -Hh/2, 0, Hh/2);
        ct.addHitGradientStop = grad.addColorStop.bind(grad); // 保留原始結構
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.25, colorLerp('#ffffff', baseColor, .2));
        grad.addColorStop(1, baseColor);
        ct.fillStyle = grad; ct.fill();
        ct.lineWidth = 6; ct.strokeStyle = strokeStyle; ct.stroke();
        ct.restore();
      };
      drawShape(1.0, 'gradient', '#000000', 16*glow);
      drawShape(innerScale, 'gradient', colorLerp(baseColor,'#ffffff',0.25), 6*glow);
    }
    function __makeArrowSprite(size, dir, baseColor, opts){
      const glow = opts.glow ?? 1;
      const innerScale = opts.innerScale ?? 0.7;
      const pad = Math.ceil(size*1.6 + 18*glow);
      const dpr = Math.min(2, window.devicePixelRatio||1);
      const off = document.createElement('canvas');
      off.width = off.height = pad*2*dpr;
      const octx = off.getContext('2d', { alpha:true });
      octx.scale(dpr, dpr);
      if (opts.low){
        const angle = dirToAngle(dir);
        const Hh = size * 1.15, Wd = size, headH = Hh * 0.55;
        octx.save(); octx.translate(pad, pad); octx.rotate(angle);
        octx.beginPath();
        octx.moveTo(0, -Hh/2);
        octx.lineTo(Wd/2, -Hh/2 + headH);
        octx.lineTo(Wd*0.22, -Hh/2 + headH);
        octx.lineTo(Wd*0.22,  Hh/2);
        octx.lineTo(-Wd*0.22, Hh/2);
        octx.lineTo(-Wd*0.22, -Hh/2 + headH);
        octx.lineTo(-Wd/2, -Hh/2 + headH);
        octx.closePath();
        const grad = octx.createLinearGradient(0, -Hh/2, 0, Hh/2);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(1, baseColor);
        octx.fillStyle = grad; octx.fill();
        octx.lineWidth = 3; octx.strokeStyle = '#000'; octx.stroke();
        octx.restore();
      } else {
        drawArrowTo(octx, pad, pad, size, dir, baseColor, glow, innerScale);
      }
      return { canvas: off, half: pad, size: pad*2 };
    }
    const __SPR = { noteHQ:[], recHQ:[], noteLQ:[], recLQ:[] };
    function __buildSprites(){
      for (let i=0;i<4;i++){
        const dir = laneDirs[i], col = laneColors[i];
        __SPR.noteHQ[i] = __makeArrowSprite(NOTE_BASE, dir, col, { glow: 0.8, innerScale: 0.7 });
        __SPR.recHQ[i]  = __makeArrowSprite(NOTE_BASE, dir, col, { glow: 1.0, innerScale: 0.7 });
        __SPR.noteLQ[i] = __makeArrowSprite(NOTE_BASE, dir, col, { low:true });
        __SPR.recLQ[i]  = __makeArrowSprite(NOTE_BASE, dir, col, { low:true });
      }
    }
    function __drawSprite(sp, x, y, scale=1){
      ctx.save(); ctx.translate(x,y); ctx.scale(scale,scale);
      ctx.drawImage(sp.canvas, -sp.half, -sp.half, sp.size, sp.size);
      ctx.restore();
    }

    /* === Perf: FPS monitor & remain counter === */
    let __fpsMA = 60, __fpsFrames = 0, __fpsLastTs = 0;
    let __useLowQuality = false;
    let __remainNotes = 0;

    function __trackFPS(ts){
      __fpsFrames++;
      if(!__fpsLastTs){ __fpsLastTs = ts; return; }
      const span = ts - __fpsLastTs;
      if (span >= 300){
        const inst = __fpsFrames * 1000 / span;
        __fpsMA = __fpsMA * 0.8 + inst * 0.2;
        __fpsFrames = 0; __fpsLastTs = ts;
        if (__fpsMA < 54) __useLowQuality = true;
        else if (__fpsMA > 58) __useLowQuality = false;
      }
    }

    /* ====== 判定 ====== */
    function judge(dtMs, lane) {
      const adt = Math.abs(dtMs);
      let rating = '', scoreDelta = 0;
      if (adt <= FNF_WINDOWS.sick)      { rating = 'SICK!'; scoreDelta = FNF_SCORES.sick; stats.sick++; combo++; }
      else if (adt <= FNF_WINDOWS.good) { rating = 'GOOD';  scoreDelta = FNF_SCORES.good; stats.good++; combo++; }
      else if (adt <= FNF_WINDOWS.bad)  { rating = 'BAD';   scoreDelta = FNF_SCORES.bad;  stats.bad++;  combo++; }
      else if (adt <= FNF_WINDOWS.shit) { rating = 'SHIT';  scoreDelta = FNF_SCORES.shit; stats.shit++; combo = Math.max(0, combo-1); }
      else { miss(); return; }
      score = Math.max(0, score + scoreDelta);
      lastJudgementText = rating;
      receptorPulse[lane] = 1;
      hitFx.push({lane, t0: nowT, life: 0.25});
      updateHUD();
      try{ hitSound.currentTime = 0; hitSound.play(); }catch{}
      if (combo > 0 && combo % 10 === 0) { comboFlash = `COMBO x${combo}!!`; setTimeout(() => comboFlash = '', 800); }
    }
    function miss() {
      lastJudgementText = 'MISS';
      combo = 0; missCount++; stats.miss++;
      score = Math.max(0, score + FNF_SCORES.miss);
      updateHUD();
      if (currentDifficulty === 'ex' && missCount > 15) triggerFailOnce('你輸了！EX 模式 MISS 超過 15 次');
    }
    function ghostTap(lane) { lastJudgementText='MISS'; combo=0; score=Math.max(0, score+FNF_SCORES.ghost); receptorPulse[lane]=0.5; updateHUD(); }
    function triggerFailOnce(msg) {
      if (gameOver) return; gameOver = true; running = false;
      stopGameLoop(); stopAndResetBgm();
      setTimeout(() => { alert(msg); goToMenu(); }, 0);
    }

    /* === 音檔路徑容錯（全形/日文引號/異體字/間距與編碼差異） === */
    function __normalizeVariants(name){
      const seen = {}; const out = [];
      function add(s){ s = s.trim(); if(!seen[s]){ seen[s]=1; out.push(s); } }
      const nfc = name.normalize('NFC');
      const nfd = name.normalize('NFD');
      function swapChars(s){
        return s
          .replace(/【/g,'[').replace(/】/g,']')
          .replace(/[「」]/g,'"')
          .replace(/（/g,'(').replace(/）/g,')')
          .replace(/☆/g,'')
          .replace(/樂/g,'楽').replace(/聲/g,'声')
          .replace(/\s{2,}/g,' ');
      }
      function under2dash(s){ return s.replace(/\s*_\s*/g,' - '); }
      function fixRoman(s){ return s.replace(/pt\.\s*II/gi,'pt.II'); }
      const cands = [nfc, nfd, swapChars(nfc), swapChars(nfd)];
      cands.forEach(s => { add(s); add(under2dash(s)); add(fixRoman(s)); });
      return out;
    }
    function __buildAudioCandidates(fileName){
      const bases = __normalizeVariants(fileName);
      const uniq = {}; const list = [];
      bases.forEach(b=>{
        ['music/'+b, 'music/'+encodeURI(b), 'music/'+encodeURIComponent(b)].forEach(u=>{
          if(!uniq[u]){ uniq[u]=1; list.push(u); }
        });
      });
      return list;
    }

    /* ====== 自動生譜（原版難度） ====== */
    function generateChart(durationSec) {
      chart = [];
      const difficulty = currentDifficulty;
      let doubleNoteChance = 0.35;
      let timeGapMin = 0.20;
      let timeGapMax = 0.45;
      if (difficulty === 'beginner')      { doubleNoteChance = 0.15; timeGapMin = 0.30; timeGapMax = 0.60; }
      else if (difficulty === 'easy')     { doubleNoteChance = 0.20; timeGapMin = 0.25; timeGapMax = 0.50; }
      else if (difficulty === 'normal')   { doubleNoteChance = 0.35; timeGapMin = 0.20; timeGapMax = 0.45; }
      else if (difficulty === 'hard')     { doubleNoteChance = 0.55; timeGapMin = 0.15; timeGapMax = 0.35; }

      if (!(difficulty === 'ex' || difficulty === 'hell')) {
        let time = 1;
        while (time < durationSec) {
          const lanesUsed = new Set();
          const notesThisFrame = [];
          const count = Math.random() < doubleNoteChance ? 2 : 1;
          while (notesThisFrame.length < count) {
            const lane = Math.floor(Math.random() * 4);
            if (!lanesUsed.has(lane)) {
              lanesUsed.add(lane);
              notesThisFrame.push({ t: time, lane, type: 'tap', hit: false, y: -50 });
            }
          }
          chart.push(...notesThisFrame);
          time += Math.random() * (timeGapMax - timeGapMin) + timeGapMin;
        }
        __remainNotes = chart.length;
        return;
      }

      // EX / HELL（較密集邏輯）
      const beat = 0.5;
      let t = 1;
      let laneCursor = 0;
      const nextLane = () => { laneCursor = (laneCursor + 1) % 4; return laneCursor; };
      const pushNote = (tt, lane) => chart.push({ t: tt, lane, type: 'tap', hit: false, y: -50 });
      const randLane = () => Math.floor(Math.random() * 4);

      while (t < durationSec) {
        if (difficulty === 'ex') {
          pushNote(t, nextLane());
          if (Math.random() < 0.60) pushNote(t, (laneCursor + 2) % 4);
          if (Math.random() < 0.35) pushNote(t + beat / 2, (laneCursor + 1) % 4);
          if (Math.random() < 0.18) {
            pushNote(t + beat / 3, randLane());
            pushNote(t + 2 * beat / 3, randLane());
          }
          t += Math.random() < 0.5 ? beat / 2 : beat;
        } else { // hell
          pushNote(t, nextLane());
          if (Math.random() < 0.85) pushNote(t, (laneCursor + 2) % 4);
          pushNote(t + beat / 2, (laneCursor + 1) % 4);
          if (Math.random() < 0.4) {
            pushNote(t + beat / 4, randLane());
            pushNote(t + 3 * beat / 4, randLane());
          }
          t += beat / 2;
        }
      }
      __remainNotes = chart.length;
    }

    /* ====== 幾何 & 命中判定 ====== */
    function noteYAtTimeFor(tHit, tNow) {
      const judge = getJudgeLineYInternal();
      if (currentDirection === 'down') return judge - (tHit - tNow) * noteSpeed;
      return judge + (tHit - tNow) * noteSpeed;
    }
    function isTapMiss(n, currentTimeSec) {
      const judge = getJudgeLineYInternal();
      const dtMs = (currentTimeSec - n.t) * 1000;
      const beyondDown = n.y > judge + MISS_Y_OFFSET;
      const beyondUp = n.y < judge - MISS_Y_OFFSET;
      const graceOver = dtMs > LATE_MISS_GRACE_MS;
      return (currentDirection === 'down') ? (beyondDown && graceOver) : (beyondUp && graceOver);
    }

    /* ====== 更新 & 繪圖 ====== */
    function updateHitbarPosition() {
      if (!hitbar || document.getElementById('gameScreen').style.display === 'none') return;
      const topPx = getJudgeLineYCss() - (HITKEY_BASE * uiScale / 2);
      hitbar.style.top = `${topPx}px`;
    }

    function positionPauseButton() {
      const btn = document.getElementById('pauseButton');
      if (!btn) return;
      btn.classList.remove('pause-bottom');
      const isCoarse = window.matchMedia('(pointer: coarse)').matches;
      if (isCoarse && currentDirection === 'up') {
        btn.classList.add('pause-bottom');
      }
    }

    function update(t, dt) {
      for (let i=0;i<chart.length;i++){
        const n = chart[i];
        n.y = noteYAtTimeFor(n.t, t);
      }
      for (let i=0;i<chart.length;i++){
        const n = chart[i];
        if (!n.hit && isTapMiss(n, t)) { n.hit = true; __remainNotes--; miss(); }
      }
      for (let i=0;i<4;i++) receptorPulse[i] = Math.max(0, receptorPulse[i] - dt*3.2);
      for (let i = hitFx.length-1; i>=0; i--) if (t - hitFx[i].t0 > hitFx[i].life) hitFx.splice(i,1);
    }

    function render({skipNotes=false} = {}) {
      const judge = getJudgeLineYInternal();
      ctx.clearRect(0, 0, W, H);

      // receptor
      const _rec = __useLowQuality ? __SPR.recLQ : __SPR.recHQ;
      for (let lane=0; lane<4; lane++){
        const x = lane * laneWidth + laneWidth / 2;
        const pulse = receptorPulse[lane];
        const s = 1 + 0.18 * pulse;
        __drawSprite(_rec[lane], x, judge, s);
      }

      // notes（視窗裁剪）
      if (!skipNotes) {
        const _note = __useLowQuality ? __SPR.noteLQ : __SPR.noteHQ;
        const top = -120, bottom = H + 120;
        for (let i=0;i<chart.length;i++){
          const n = chart[i];
          if (n.hit) continue;
          if (n.y < top || n.y > bottom) continue;
          const x = n.lane * laneWidth + laneWidth / 2;
          __drawSprite(_note[n.lane], x, n.y, 1);
        }
      }

      // 命中外圈
      for (let i=0;i<hitFx.length;i++){
        const fx = hitFx[i];
        const p = Math.min(1, (nowT - fx.t0) / fx.life);
        const x = fx.lane * laneWidth + laneWidth / 2;
        drawRing(x, judge, 18 + 80*p, 1 - p);
      }

      // 判定文字
      if (lastJudgementText !== '-') {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        const offset = (currentDirection === 'up') ? 120 : -40;
        ctx.fillText(lastJudgementText, W / 2, judge + offset);
      }

      if (comboFlash) {
        ctx.fillStyle = '#ff78b5';
        ctx.font = 'bold 36px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(comboFlash, W / 2, H / 2 - 100);
      }
    }

    function endGameAndShowResult(){
      running = false;
      lastJudgementText = 'END';
      updateHUD();
      document.getElementById('finalSong').textContent = currentSongTitle;
      document.getElementById('finalDiff').textContent = currentDifficulty.toUpperCase();
      document.getElementById('finalDir').textContent  = (currentDirection === 'up' ? '上升' : '下落');
      document.getElementById('finalJudge').textContent= (currentJudgeMode === 'old' ? 'Old' : 'New');
      document.getElementById('finalScore').textContent = score;
      document.getElementById('statSick').textContent = stats.sick;
      document.getElementById('statGood').textContent = stats.good;
      document.getElementById('statBad').textContent = stats.bad;
      document.getElementById('statShit').textContent = stats.shit;
      document.getElementById('statMiss').textContent = stats.miss;
      showOnly('endScreen');
      phase = 'menu';
    }

    let songEnded = false;

    function loop(ts) {
      if (paused) return;
      if (!prevTs) { prevTs = ts; __lastRenderTs = ts; }
      nowT = (ts - startTime) / 1000;
      const dt = Math.max(0, (ts - prevTs) / 1000);
      prevTs = ts;

      update(nowT, dt);
      __trackFPS(ts);

      // 手機穩定 60fps 的視覺節奏鎖（不影響判定時間）
      let doRender = true;
      if (__fpsMode === 'stable60' && IS_MOBILE) {
        if (ts - __lastRenderTs < __TARGET_INTERVAL - 0.5) {
          doRender = false;
        } else {
          const steps = Math.max(1, Math.floor((ts - __lastRenderTs) / __TARGET_INTERVAL));
          __lastRenderTs += steps * __TARGET_INTERVAL;
        }
      }
      if (doRender) render();

      if (songEnded || __remainNotes <= 0) {
        endGameAndShowResult();
        return;
      }

      loopId = requestAnimationFrame(loop);
    }
    function stopGameLoop(){ try{ cancelAnimationFrame(loopId); }catch{} loopId=null; prevTs=0; }

    /* ====== 倒數處理（可中止） ====== */
    function showCountdown(startCallback) {
      cancelCountdown();
      isCountingDown = true;
      phase = 'countdown';

      // 倒數時先顯示 receptor（不畫音符）
      const countdownLoop = () => {
        if (!isCountingDown) return;
        render({skipNotes:true});
        countdownRAF = requestAnimationFrame(countdownLoop);
      };
      countdownLoop();

      const el = document.getElementById('countdownText');
      el.style.display = 'block';
      const steps = ['Ready', '3', '2', '1', 'Go!'];
      const stepDur = 700;

      const playStep = (i) => {
        if (!isCountingDown) return;
        el.textContent = steps[i];
        el.style.animation = 'none';
        void el.offsetWidth;
        el.style.animation = 'popScale .55s ease-out';
      };

      for (let i=0;i<steps.length;i++){
        countdownTimers.push(setTimeout(()=>playStep(i), i*stepDur));
      }
      countdownTimers.push(setTimeout(()=>{
        if (!isCountingDown) return;
        el.style.display = 'none';
        isCountingDown = false;
        try { cancelAnimationFrame(countdownRAF); } catch {}
        startCallback();
      }, steps.length*stepDur));
    }

    function cancelCountdown() {
      if (!isCountingDown && countdownTimers.length===0 && !countdownRAF) return;
      isCountingDown = false;
      countdownTimers.forEach(id=>clearTimeout(id));
      countdownTimers = [];
      try{ cancelAnimationFrame(countdownRAF); }catch{}
      countdownRAF = null;
      const el = document.getElementById('countdownText');
      el.style.animation = 'none';
      el.style.display = 'none';
    }

    function stopAndResetBgm(){
      try { bgm.pause(); } catch {}
      try { bgm.currentTime = 0; } catch {}
    }

    /* ====== 輸入（鍵盤＋觸控） ====== */
    window.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();

      if (k in keyToLane) {
        if (phase === 'playing') onLanePress(keyToLane[k]);
        e.preventDefault();
        return;
      }

      if (e.key === 'Escape') {
        if (phase === 'countdown') {
          cancelCountdown();
          goToMenu();
          return;
        }
        if (phase === 'playing') { paused ? resumeGame() : pauseGame(); return; }
        if (phase === 'paused')  { resumeGame(); return; }
      }
    });

    canvas.addEventListener('pointerdown', (e) => {
      if (phase !== 'playing') return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const cssLaneWidth = rect.width / 4;
      const lane = Math.min(3, Math.max(0, Math.floor(x / cssLaneWidth)));
      onLanePress(lane);
    }, { passive:false });

    function onLanePress(lane) {
      if (!running) return;
      const tNow = (performance.now() - startTime) / 1000;

      let bestIdx = -1, bestAbs = Infinity;
      for (let i = 0; i < chart.length; i++) {
        const n = chart[i];
        if (n.hit || n.lane !== lane) continue;
        const dtMs = (tNow - n.t) * 1000;
        const adt = Math.abs(dtMs);
        if (adt <= TOUCH_WINDOW_MS && adt < bestAbs) { bestAbs = adt; bestIdx = i; }
      }

      if (bestIdx >= 0) {
        const n = chart[bestIdx];
        judge((tNow - n.t) * 1000, lane);
        n.hit = true;
        __remainNotes--;
        flashKeyByLane(lane);
      } else {
        if (currentJudgeMode === 'old') ghostTap(lane);
        flashKeyByLane(lane);
      }
    }

    /* ====== 音量：UI + 持久化 ====== */
    function initVolumeUI(){
      const slider = document.getElementById('volumeSlider');
      const label  = document.getElementById('volumeValue');
      let v = parseFloat(localStorage.getItem('dfjk_volume') || '0.8');
      if (isNaN(v)) v = 0.8;
      slider.value = String(v);
      label.textContent = `${Math.round(v*100)}%`;
      try{ bgm.volume = v; hitSound.volume = v; }catch{}
      slider.addEventListener('input', ()=>{
        const nv = parseFloat(slider.value);
        label.textContent = `${Math.round(nv*100)}%`;
        try{ bgm.volume = nv; hitSound.volume = nv; }catch{}
        localStorage.setItem('dfjk_volume', String(nv));
      });
    }

    /* ====== 音樂播放提醒 & 監測 ====== */
    let __audioWatch = { timer:null, tries:0 };
    function showAudioWarn(msg, showRetry){
      const box = document.getElementById('audioWarn');
      const txt = document.getElementById('audioWarnText');
      const btn = document.getElementById('audioRetryBtn');
      txt.textContent = msg;
      btn.style.display = showRetry ? 'inline-block' : 'none';
      box.style.display = 'inline-block';
      if (!showRetry){
        setTimeout(()=>{ box.style.display='none'; }, 4000);
      }
    }
    function hideAudioWarn(){
      const box = document.getElementById('audioWarn');
      box.style.display = 'none';
    }
    function startAudioWatch(){
      clearAudioWatch();
      __audioWatch.tries = 0;
      __audioWatch.timer = setInterval(()=>{
        __audioWatch.tries++;
        if (bgm.currentTime > 0 && !bgm.paused && !bgm.seeking){
          hideAudioWarn();
          clearAudioWatch();
          return;
        }
        if (__audioWatch.tries === 5){
          showAudioWarn('音樂似乎沒有播放，請點一下「重試播放」或確認檔案存在。', true);
        }
        if (__audioWatch.tries > 20){
          clearAudioWatch();
        }
      }, 700);
    }
    function clearAudioWatch(){
      if (__audioWatch.timer){ clearInterval(__audioWatch.timer); __audioWatch.timer=null; }
    }
    function retryBgm(){
      try{
        bgm.play().then(()=>{ hideAudioWarn(); }).catch(()=>{
          showAudioWarn('瀏覽器阻擋自動播放，請再點一次重試或輕觸畫面。', true);
        });
        startAudioWatch();
      }catch(e){
        showAudioWarn('播放重試失敗。', true);
      }
    }

    /* ====== 流程 ====== */
    function startGame() {
      if (!selectedSongFile) { alert('請先選擇音樂'); showMusic(); return; }

      const difficulty = document.getElementById('difficultySelect').value;
      const speedMultiplierSelect = document.getElementById('speedMultiplier');
      const dir = document.getElementById('noteDirection').value;
      const jmode = document.getElementById('judgeMode').value;
      currentDifficulty = difficulty;
      currentDirection  = dir;
      currentJudgeMode  = jmode;

      let multiplier = parseFloat(speedMultiplierSelect.value);
      if      (difficulty === 'beginner') multiplier = 0.8;
      else if (difficulty === 'easy')     multiplier = 0.9;
      else if (difficulty === 'ex')       multiplier = 1.8;
      noteSpeed = baseNoteSpeed * multiplier;

      document.body.classList.toggle('ex-mode', difficulty === 'ex');

      // 重置狀態
      stopGameLoop();
      score = 0; combo = 0; lastJudgementText = '-'; comboFlash = '';
      chart = []; paused = false; running = true; missCount = 0; gameOver = false;
      stats = { sick:0, good:0, bad:0, shit:0, miss:0 };
      elapsedTimeBeforePause = 0; nowT = 0; prevTs = 0;
      for (let i=0;i<4;i++) receptorPulse[i]=0;
      hitFx.length = 0;
      updateHUD();

      currentSongTitle = selectedSongFile.replace(/\.mp3$/i, '');
      (function tryAudioFallback(){
        const cand = __buildAudioCandidates(selectedSongFile);
        let i = 0;
        bgm.onerror = function(){
          if (++i < cand.length) { bgm.src = cand[i]; bgm.load(); }
          else { showAudioWarn('找不到音樂檔案或無法讀取，請確認 /music 目錄與檔名。', true); }
        };
        bgm.onstalled = ()=> showAudioWarn('音樂載入停滯（網路延遲或檔案問題）。', true);
        bgm.onsuspend = ()=> {}; // 部分瀏覽器正常行為，先不提示
        bgm.onabort   = ()=> showAudioWarn('音樂載入被中止。', true);
        bgm.onplaying = ()=> { hideAudioWarn(); clearAudioWatch(); };
        bgm.ontimeupdate = ()=> { if (bgm.currentTime>0) { hideAudioWarn(); } };
        bgm.src = cand[i];
        bgm.load();
      })();

      // 追蹤音樂結束
      songEnded = false;
      bgm.onended = () => { songEnded = true; };

      showOnly('gameScreen');
      phase = 'countdown';

      applyDesktopScale();
      recomputeLayout();
      updateHUD();
      __lastRenderTs = 0;

      // 準備譜面
      let chartFinalized = false;
      generateChart(120);
      bgm.onloadedmetadata = () => {
        if (chartFinalized) return;
        const durationSec = (!isNaN(bgm.duration) && bgm.duration > 0) ? bgm.duration : 120;
        generateChart(durationSec);
        chartFinalized = true;
      };

      // 建立 sprites（一次性）
      __buildSprites();

      // 倒數
      showCountdown(() => {
        if (phase !== 'countdown') return;
        phase = 'playing';
        freezeLayout();     // 進關即固定幾何，打擊圖示不再漂
        startTime = performance.now();
        try {
          const p = bgm.play();
          if (p && typeof p.then === 'function'){
            p.then(()=>{ hideAudioWarn(); }).catch(()=>{
              showAudioWarn('瀏覽器阻擋自動播放，請點「重試播放」。', true);
            });
          }
        } catch {}
        startAudioWatch();
        loopId = requestAnimationFrame(loop);
      });
    }

    function pauseGame() {
      if (phase === 'countdown') {
        cancelCountdown();
        goToMenu();
        return;
      }
      if (!running || paused) return;
      paused = true;
      phase = 'paused';
      try { bgm.pause(); } catch {}
      stopGameLoop();
      elapsedTimeBeforePause = (performance.now() - startTime) / 1000;
      unfreezeLayout();   // 暫停解除凍結，允許視窗調整
      document.getElementById('gameScreen').classList.add('blur');
      showOnly('pauseScreen');
    }

    function resumeGame() {
      if (!paused) return;
      paused = false;
      phase = 'playing';
      showOnly('gameScreen');
      document.getElementById('gameScreen').classList.remove('blur');

      applyDesktopScale();
      recomputeLayout();
      freezeLayout();     // 繼續時再度固定

      startTime = performance.now() - (elapsedTimeBeforePause * 1000);
      __lastRenderTs = 0;
      try {
        const p = bgm.play();
        if (p && typeof p.then === 'function'){
          p.then(()=>{ hideAudioWarn(); }).catch(()=>{
            showAudioWarn('瀏覽器阻擋自動播放，請點「重試播放」。', true);
          });
        }
      } catch {}
      startAudioWatch();
      loopId = requestAnimationFrame(loop);
    }

    /* ====== 初始化 ====== */
    function renderIdle() {
      if (document.getElementById('gameScreen').style.display === 'block') return;
      recomputeLayout();
    }

    function onViewportChanged(){
      if (__layoutFrozen) return; // 打歌中不響應視窗變化，避免位移
      if (phase === 'playing' || phase === 'countdown') {
        applyDesktopScale();
        recomputeLayout();
      }
    }

    applyDesktopScale();
    fillSongList();
    initVolumeUI();
    window.addEventListener('resize', onViewportChanged, { passive: true });
    window.addEventListener('scroll', () => { if (!__layoutFrozen && (phase==='playing'||phase==='countdown')) recomputeLayout(); }, { passive: true });
    if (window.visualViewport) {
      ['resize','scroll'].forEach(ev => {
        window.visualViewport.addEventListener(ev, onViewportChanged, { passive: true });
      });
    }
    window.addEventListener('orientationchange', () => {
      unfreezeLayout();
      applyDesktopScale();
      recomputeLayout();
      if (phase === 'playing' || phase === 'countdown') freezeLayout();
    }, { passive: true });

    // 只在遊戲階段才阻止右鍵/縮放/雙擊，避免在選單/選項頁操作回溯
    document.addEventListener("contextmenu", e => { if (phase==='playing'||phase==='countdown') e.preventDefault(); });
    document.addEventListener('gesturestart', e => { if (phase==='playing'||phase==='countdown') e.preventDefault(); });
    document.addEventListener('dblclick', e => { if (phase==='playing'||phase==='countdown') e.preventDefault(); });

    goToMenu();
  </script>
</body>
</html>











